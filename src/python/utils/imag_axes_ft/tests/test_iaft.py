"""
==========================================================================
CoQuí: Correlated Quantum ínterface

Copyright (c) 2022-2025 Simons Foundation & The CoQuí developer team

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==========================================================================
"""

from mpi4py import MPI
import pytest
import os
import numpy as np
import h5py

import coqui
from coqui.utils.imag_axes_ft import IAFT


def ir_filename(lmbda: float, prec: float):
    if lmbda == 100:
        lmbda_str = "1e2"
    elif lmbda == 1000:
        lmbda_str = "1e3"
    elif lmbda == 10000:
        lmbda_str = "1e4"
    elif lmbda == 100000:
        lmbda_str = "1e5"
    elif lmbda == 1000000:
        lmbda_str = "1e6"
    else:
        raise ValueError("Unsupported lambda value")

    if prec == 1e-6:
        prec_str = "1e-06"
    elif prec == 1e-10:
        prec_str = "1e-10"
    elif prec == 1e-15:
        prec_str = "1e-15"
    else:
        raise ValueError("Unsupported precision value")

    filename = coqui.INSTALL_DIR+"/data/ir/"+lmbda_str+"."+prec_str+".h5"
    if os.path.isfile(filename):
        return filename

    filename = coqui.PROJECT_SOURCE_DIR+"/src/numerics/imag_axes_ft/ir/data/ir/" + lmbda_str + "." + prec_str + ".h5"
    if os.path.isfile(filename):
        return filename

    raise FileNotFoundError(f"IR data file not found for lambda={lmbda}, prec={prec}")


def compare_ir_h5(wmax: float, prec: str):
    """
    Compare the IR basis generated by sparse_ir with the precomputed basis stored in the HDF5 file.
    This check ensures compatibility of sparse_ir across different library versions.

    :param wmax: frequency cutoff
    :param prec: "low" (1e-6), "medium" (1e-10), "high" (1e-15)
    """
    ir = IAFT(beta=1.0, wmax=wmax, prec=prec)
    with h5py.File(ir_filename(ir.lmbda, ir.prec), "r") as ar:
        tau_mesh = (ar["fermion/tau_mesh"][()] + 1.0) * ir.beta / 2.0
        wn_mesh = ar["fermion/wn_mesh"][()]
        assert np.allclose(tau_mesh, ir.tau_mesh_f, atol=1e-12)
        assert np.allclose(wn_mesh, ir.wn_mesh(stats='f'), atol=1e-12)

        tau_mesh = (ar["boson/tau_mesh"][()] + 1.0) * ir.beta / 2.0
        wn_mesh = ar["boson/wn_mesh"][()]
        assert np.allclose(tau_mesh, ir.tau_mesh_b, atol=1e-12)
        assert np.allclose(wn_mesh, ir.wn_mesh(stats='b'), atol=1e-12)

        Ttw = ar["fermion/Ttw"][()].view(complex)[...,0] * np.sqrt(2)
        Twt = ar["fermion/Twt"][()].view(complex)[...,0] / np.sqrt(2)
        assert np.allclose(Ttw, ir.Ttw_ff, atol=1e-12)
        assert np.allclose(Twt, ir.Twt_ff, atol=1e-12)

        Ttw = ar["boson/Ttw"][()].view(complex)[...,0] * np.sqrt(2)
        Twt = ar["boson/Twt"][()].view(complex)[...,0] / np.sqrt(2)
        assert np.allclose(Ttw, ir.Ttw_bb, atol=1e-12)
        assert np.allclose(Twt, ir.Twt_bb, atol=1e-12)



def test_ir_compatibility():
    wmax_list = [90.0, 900.0, 9000.0, 90000.0]
    for wmax in wmax_list:
        compare_ir_h5(wmax=wmax, prec="low")
        compare_ir_h5(wmax=wmax, prec="medium")
        compare_ir_h5(wmax=wmax, prec="high")