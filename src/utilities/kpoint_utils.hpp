/**
 * ==========================================================================
 * CoQuí: Correlated Quantum ínterface
 *
 * Copyright (c) 2022-2025 Simons Foundation & The CoQuí developer team
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ==========================================================================
 */


#ifndef UTILITIES_KPOINT_UTILS_HPP
#define UTILITIES_KPOINT_UTILS_HPP

#include <type_traits>
#include "IO/app_loggers.h"
#include "utilities/check.hpp"
#include "utilities/concepts.hpp"
#include "nda/nda.hpp"
#include "numerics/shared_array/detail/concepts.hpp"
#include "mpi3/environment.hpp"
#include "mpi3/communicator.hpp"
#include "mpi3/operation.hpp"
#include "numerics/device_kernels/kernels.h"
#include "utilities/details/kpoint_impl.hpp"

namespace mpi3 = boost::mpi3;

namespace utils
{

/*
 * A collection of useful routines to manipulate kpoint grids
 */

/*
 * Given a regular, "complete" grid of kpts, Qpts  and a set of reciprocal vectors, calculates:
 *   - qk_to_k2[a,b] = c: where Qpts[a] = kpts[b] - kpts[c] - G,
 *   			  for some G in reciprocal cell    
 *   - qminus[a] = b, where Qpts[a] = G - Qpts[b], for some G in reciprocal cell.
 */  
template<nda::ArrayOfRank<2> SDMat, nda::ArrayOfRank<2> DMat, nda::MemoryArrayOfRank<2> IMat, nda::MemoryArrayOfRank<1> IVec>
void calculate_Qpt_maps(utils::Communicator auto& comm, SDMat const& bg, DMat const& kpts, DMat const& Qpts, IMat& qk_to_k2, IVec& qminus)
{
  int nk = kpts.shape()[0];
  utils::check(bg.shape()[0] == 3 and bg.shape()[1] == 3, "Shape mismatch");
  utils::check(kpts.shape()[1] == 3, "Shape mismatch");
  utils::check(Qpts.shape()[0] == nk and Qpts.shape()[1] == 3, "Shape mismatch");
  utils::check(qk_to_k2.shape()[0] == nk and qk_to_k2.shape()[1] == nk, "Shape mismatch");
  utils::check(qminus.shape()[0] == nk, "Shape mismatch"); 
  
  app_log(3,"Initializing Qpt maps");
  qk_to_k2() = -1;
  for(int ik_ka=comm.rank(); ik_ka<nk*nk; ik_ka+=comm.size()) {
    int ik = ik_ka / nk;
    int ka = ik_ka % nk;
    for(int kb=0; kb<nk; kb++) { 
      double d0 = std::abs(kpts(ka, 0) - kpts(kb, 0) - Qpts(ik, 0));
      double d1 = std::abs(kpts(ka, 1) - kpts(kb, 1) - Qpts(ik, 1));
      double d2 = std::abs(kpts(ka, 2) - kpts(kb, 2) - Qpts(ik, 2));
      // shift to [0,1) and measure distance with nearest integer
      d0 -= std::floor(d0);
      d1 -= std::floor(d1);
      d2 -= std::floor(d2);
      // measure distance to nearest integer in case d0 = 1.0 - small
      d0 -= std::round(d0); 
      d1 -= std::round(d1); 
      d2 -= std::round(d2);
      if( d0*d0 + d1*d1 + d2*d2 < 1.0e-8 ) {
        utils::check(qk_to_k2(ik,ka) == -1, "Problems defining k2 = q-k1 mapping.");
        qk_to_k2(ik,ka) = kb;
        goto found_qk; 
      }
    } // kb
found_qk:
    utils::check(qk_to_k2(ik,ka) >= 0, "Could not solve: k2 = q-k1.");
  } // ik_ka
  comm.all_reduce_in_place_n(qk_to_k2.data(), nk*nk, mpi3::max<>{}); 

  qminus() = -1;
  for(int ik=comm.rank(); ik<nk; ik+=comm.size()) {
    for(int ka=0; ka<nk; ka++) { 
      double d0 = std::abs(Qpts(ik, 0) + Qpts(ka, 0));
      double d1 = std::abs(Qpts(ik, 1) + Qpts(ka, 1));
      double d2 = std::abs(Qpts(ik, 2) + Qpts(ka, 2));
      // shift to [0,1) and measure distance with nearest integer
      d0 -= std::floor(d0);
      d1 -= std::floor(d1);
      d2 -= std::floor(d2);
      // measure distance to nearest integer in case d0 = 1.0 - small
      d0 -= std::round(d0);
      d1 -= std::round(d1);
      d2 -= std::round(d2);
      if( d0*d0 + d1*d1 + d2*d2 < 1.0e-8 ) {
        utils::check(qminus(ik) == -1, "Problems defining Q = G - (-Q) mapping.");
        qminus(ik) = ka;
      }
    } // ka
    utils::check(qminus(ik) >= 0, "Could not find -q.");
  } // ik
  comm.all_reduce_in_place_n(qminus.data(), nk, mpi3::max<>{}); 
}

/*
 * Given a list of Qpts, kpts and the qk_to_k2 mapping generated by calculate_Qpt_maps, 
 * this routine calculates the list of all G vectors found in Qpts[a] + G = kpts[b] - kpts[c],
 * and generates a map from G[n] to the list of corresponding {q,k}. 
 *   - G[n] = {Gx,Gy,Gz} : list of G vectors 
 *   - Gn_to_qk[n][i] = {q,k}, where Qpts[q] + G[n] = kpts[k] - kpts[qk_to_k2[k]] 
 */
template<nda::ArrayOfRank<2> DMat, nda::ArrayOfRank<2> IMat>
std::tuple<nda::array<double,2>, std::vector<std::vector<int>>> 
calculate_Gn_map(DMat const& kpts, DMat const& Qpts, IMat const& qk_to_k2) 
{
  int nk = kpts.shape()[0];
  int nq = Qpts.shape()[0];
  utils::check(kpts.shape()[1] == 3, "Shape mismatch");
  utils::check(Qpts.shape()[0] == nk and Qpts.shape()[1] == 3, "Shape mismatch");
  utils::check(qk_to_k2.shape()[0] == nk and qk_to_k2.shape()[1] == nk, "Shape mismatch");
  std::vector<std::tuple<double,double,double>> Gijk;
  std::vector<std::vector<int>> qk;

  std::tuple<double,double,double> dk;
  for(int iq=0; iq<nq; iq++) {
    for(int ka=0; ka<nk; ka++) {
      int kb = qk_to_k2(iq,ka);
      dk = std::make_tuple(kpts(ka,0)-kpts(kb,0)-Qpts(iq,0),
			   kpts(ka,1)-kpts(kb,1)-Qpts(iq,1), 
			   kpts(ka,2)-kpts(kb,2)-Qpts(iq,2)); 
      auto it = std::find_if(std::begin(Gijk), std::end(Gijk),
                             [&](auto const& tp) {
        double a = std::get<0>(tp)-std::get<0>(dk);
        double b = std::get<1>(tp)-std::get<1>(dk);
        double c = std::get<2>(tp)-std::get<2>(dk);
	return ( (a*a + b*b + c*c) < 1.0e-8 );
				}); 
      if( it != std::end(Gijk)) {
        int n = std::distance(std::begin(Gijk),it);
        utils::check(qk.size()>=n,"calculate_Gn_map: Error #1");
        qk[n].emplace_back(iq);
        qk[n].emplace_back(ka);
      } else {
        Gijk.emplace_back(dk);
        qk.emplace_back();
        qk.back().emplace_back(iq);
        qk.back().emplace_back(ka);
      }
    } // ka
  } // iq 

  // now construct Gn
  int n = Gijk.size();
  nda::array<double,2> Gn(n,3);
  long cnt(0);
  for( int a=0; a<n; a++ ) {
    cnt += qk[a].size();
    Gn(a,0) = std::get<0>(Gijk[a]); 
    Gn(a,1) = std::get<1>(Gijk[a]); 
    Gn(a,2) = std::get<2>(Gijk[a]); 
  }
 
  utils::check( cnt%2==0, "calculate_Gn_map: qk size mismatch");
  utils::check( cnt/2==nq*nk, "calculate_Gn_map: qk size mismatch");
  return std::make_tuple(Gn,qk);
}

/*
 * Given a list of Qpts, kpts and the qk_to_k2 mapping generated by calculate_Qpt_maps, 
 * this routine calculates the list of all G vectors found in Qpts[a] + G = kpts[b] - kpts[c],
 * and generates a map from qk to n. 
 *   - G[n] = {Gx,Gy,Gz} : list of G vectors 
 *   - Gn_to_qk[n][i] = {q,k}, where Qpts[q] + G[n] = kpts[k] - kpts[qk_to_k2[k]] 
 */
template<nda::ArrayOfRank<2> DMat, nda::ArrayOfRank<2> IMat>
std::tuple<nda::array<double,2>, nda::array<int,2>> 
calculate_Gn_map_v2(DMat const& kpts, DMat const& Qpts, IMat const& qk_to_k2) 
{
  int nk = kpts.shape()[0];
  int nq = Qpts.shape()[0];
  utils::check(kpts.shape()[1] == 3, "Shape mismatch");
  utils::check(Qpts.shape()[0] == nk and Qpts.shape()[1] == 3, "Shape mismatch");
  utils::check(qk_to_k2.shape()[0] == nk and qk_to_k2.shape()[1] == nk, "Shape mismatch");
  std::vector<std::tuple<double,double,double>> Gijk;
  nda::array<int,2> qk(nq,nk);

  std::tuple<double,double,double> dk;
  for(int iq=0; iq<nq; iq++) {
    for(int ka=0; ka<nk; ka++) {
      int kb = qk_to_k2(iq,ka);
      dk = std::make_tuple(kpts(ka,0)-kpts(kb,0)-Qpts(iq,0),
			   kpts(ka,1)-kpts(kb,1)-Qpts(iq,1), 
			   kpts(ka,2)-kpts(kb,2)-Qpts(iq,2)); 
      auto it = std::find_if(std::begin(Gijk), std::end(Gijk),
                             [&](auto const& tp) {
        double a = std::get<0>(tp)-std::get<0>(dk);
        double b = std::get<1>(tp)-std::get<1>(dk);
        double c = std::get<2>(tp)-std::get<2>(dk);
	return ( (a*a + b*b + c*c) < 1.0e-8 );
				}); 
      if( it != std::end(Gijk)) {
        int n = std::distance(std::begin(Gijk),it);
        qk(iq,ka) = n;
      } else {
        qk(iq,ka) = Gijk.size();
        Gijk.emplace_back(dk);
      }
    } // ka
  } // iq 

  // now construct Gn
  int n = Gijk.size();
  nda::array<double,2> Gn(n,3);
  for( int a=0; a<n; a++ ) {
    Gn(a,0) = std::get<0>(Gijk[a]); 
    Gn(a,1) = std::get<1>(Gijk[a]); 
    Gn(a,2) = std::get<2>(Gijk[a]); 
  }
 
  return std::make_tuple(std::move(Gn),std::move(qk));
}

/**
 * @param [input] mill - Miller indices (npw, 3) for G vectors on the k-grid
 * @param [output] k2g - map between kinetic and FFT mesh
 * @param [intput] mesh - fft mesh
 */
void generate_k2g(nda::ArrayOfRank<2> auto const& mill,
                  nda::ArrayOfRank<1> auto && k2g,
                  nda::stack_array<long,3> const& mesh)
{
  utils::check(mill.shape()[1] == 3, "generate_k2g - size mismatch: {},{}",mill.shape()[1],3);
  utils::check(mesh.shape()[0] == 3, "generate_k2g - size mismatch: {},{}",mesh.shape()[0],3);
  utils::check(mill.shape()[0] == k2g.shape()[0], "generate_k2g - size mismatch: {},{}",
	       mill.shape()[0], k2g.shape()[0]);
  long NX = int(mesh(0)), NY = int(mesh(1)), NZ = int(mesh(2));
  auto it = k2g.begin();
  for( int i=0; i<mill.shape()[0]; i++) {
    // G_i = mill(i,0) * b1 + mill(i,1) * b2 + mill(i,2) * b3
    long n1 = mill(i,0); if(n1<0) n1 += NX;
    long n2 = mill(i,1); if(n2<0) n2 += NY; 
    long n3 = mill(i,2); if(n3<0) n3 += NZ; 
    utils::check(n1 < NX, "generate_k2g: Index out of range. i:{}, n:{}, NX:{}",i,n1,NX);
    utils::check(n2 < NY, "generate_k2g: Index out of range. i:{}, n:{}, NY:{}",i,n2,NY);
    utils::check(n3 < NZ, "generate_k2g: Index out of range. i:{}, n:{}, NZ:{}",i,n3,NZ);
    *(it++) = (n1*NY + n2)*NZ + n3;
  }
}

void generate_miller_index(nda::ArrayOfRank<1> auto const& k2g,
                           nda::ArrayOfRank<2> auto && mill,
                           nda::stack_array<long,3> const& mesh)
{
  utils::check(mill.shape()[1] == 3, "generate_miller_index - size mismatch: {},{}",mill.shape()[1],3);
  utils::check(mesh.shape()[0] == 3, "generate_miller_index - size mismatch: {},{}",mesh.shape()[0],3);
  utils::check(mill.shape()[0] == k2g.shape()[0], "generate_miller_index - size mismatch: {},{}",
               mill.shape()[0], k2g.shape()[0]);
  long NX = mesh(0), NY = mesh(1), NZ = mesh(2);
  long NX2 = NX/2, NY2 = NY/2, NZ2 = NZ/2;
  for( auto [i,n] : itertools::enumerate(k2g) ) {
    mill(i,2) = n%NZ; if( mill(i,2) > NZ2 ) mill(i,2) -= NZ;     
    long n_ = n/NZ;
    mill(i,1) = n_%NY; if( mill(i,1) > NY2 ) mill(i,1) -= NY;     
    mill(i,0) = n_/NY; if( mill(i,0) > NX2 ) mill(i,0) -= NX;     
    utils::check(std::abs(mill(i,0)) <= NX2, "generate_miller_index: Index out of range. mill:{}, NX2:{}",mill(i,0),NX2);
    utils::check(std::abs(mill(i,1)) <= NY2, "generate_miller_index: Index out of range. mill:{}, NY2:{}",mill(i,1),NY2);
    utils::check(std::abs(mill(i,2)) <= NZ2, "generate_miller_index: Index out of range. mill:{}, NZ2:{}",mill(i,2),NZ2);
  }
}

nda::array<int,1> kp_grid_dims(nda::ArrayOfRank<2> auto const& kp)
{
  decltype(nda::range::all) all;
  utils::check(kp.extent(1) == 3, "Size mismatch");
  int nk = kp.extent(0);
  auto dim = nda::array<int,1>::zeros({3});
  nda::stack_array<double, 3> dk;
  // associated qp grid must be gamma centered, so count number of elements along axes
  for(int k=0; k<nk; k++) {
    dk = kp(k,all) - kp(0,all);
    if( std::abs(dk(1)*dk(1)+dk(2)*dk(2)) < 1e-12 ) dim(0)+=1;
    if( std::abs(dk(0)*dk(0)+dk(2)*dk(2)) < 1e-12 ) dim(1)+=1;
    if( std::abs(dk(0)*dk(0)+dk(1)*dk(1)) < 1e-12 ) dim(2)+=1;
  }
  if(dim(0)*dim(1)*dim(2) == nk) 
    return dim; 
  else 
    return nda::array<int,1>::zeros({3});
}

void generate_and_check_qgrid(nda::ArrayOfRank<1> auto const& dim,
                              nda::ArrayOfRank<2> auto & qp)
{
  // make copy since you are applying PBC
  utils::check(dim.extent(0) == 3, "Size mismatch");
  utils::check(qp.extent(0) == dim(0)*dim(1)*dim(2), "Size mismatch");
  utils::check(qp.extent(1) == 3, "Size mismatch");
  int nq = qp.extent(0);    

  int ni = int(dim(0))/2; 
  int nj = int(dim(1))/2; 
  int nk = int(dim(2))/2; 
  int mni = -ni; if(int(dim(0))%2==0) ni--;
  int mnj = -nj; if(int(dim(1))%2==0) nj--; 
  int mnk = -nk; if(int(dim(2))%2==0) nk--;

  // gamma-centered dim-dimension qpoint grid
  int ik=0;
  for(int i=mni; i<=ni; ++i) {
    for (int j=mnj; j<=nj; ++j) {
      for(int k=mnk; k<=nk; ++k, ik++) { 
        qp(ik,0) = double(i)/double(dim(0));
        qp(ik,1) = double(j)/double(dim(1));
        qp(ik,2) = double(k)/double(dim(2));
      }
    }
  }	
  utils::check(ik==nq, "Internal Error: ik != nq, ik:{}, nq:{}",ik,nq);
}

void g2kin(nda::ArrayOfRank<1> auto const& kp,
           nda::MemoryArrayOfRank<2> auto const& gv,
           nda::MemoryArrayOfRank<1> auto & g2)
{
  using value_t = typename std::decay_t<decltype(g2)>::value_type;
  utils::check(gv.extent(0) == g2.size(), "Shape msimatch.");
  utils::check(gv.extent(1) == 3, "Shape msimatch.");
  long ng = gv.extent(0);
  g2() = value_t{0.0};

  for( auto i : nda::range(ng) ) {
    double gx = gv(i,0)+kp(0);
    double gy = gv(i,1)+kp(1);
    double gz = gv(i,2)+kp(2);
    g2(i) = value_t{0.5*(gx*gx+gy*gy+gz*gz)};
  }
}

void g2kin(nda::ArrayOfRank<2> auto const& kp,
           nda::MemoryArrayOfRank<2> auto const& gv,
           nda::MemoryArrayOfRank<2> auto & g2)
{
  using value_t = typename std::decay_t<decltype(g2)>::value_type;
  utils::check(kp.extent(0) == g2.extent(0), "Shape msimatch.");
  utils::check(kp.extent(1) == 3, "Shape msimatch.");
  utils::check(gv.extent(0) == g2.extent(1), "Shape msimatch.");
  utils::check(gv.extent(1) == 3, "Shape msimatch.");
  long ng = gv.extent(0);
  long nk = kp.extent(0);
  g2() = value_t{0.0};

  for( auto k : nda::range(nk) ) {
    for( auto i : nda::range(ng) ) {
      double gx = gv(i,0)+kp(k,0);
      double gy = gv(i,1)+kp(k,1);
      double gz = gv(i,2)+kp(k,2);
      g2(k,i) = value_t{0.5*(gx*gx+gy*gy+gz*gz)};
    }
  }
}

/**
 * @param lattv - [INPUT] translational vector
 * @param G - [INPUT] G-vector in cartesian coordinates
 * @param f - [OUTPUT] phase factor f(i, j, k) = exp(i * G * r), where r = (i, j, k) * lattv
 * MAM: factor of 2*pi assumed included in definition of G
 *      e.g. kpts and recv are in cartesian coordinates with factor of 2*pi included...
 */
inline void rspace_phase_factor(nda::stack_array<double,3,3> const& lattv, 
				nda::ArrayOfRank<1> auto const& G,
				nda::ArrayOfRank<3> auto && f)
{
  constexpr auto MEM = memory::get_memory_space<std::decay_t<decltype(f())>>();  
  using value_type = typename std::decay_t<decltype(f)>::value_type;
  static_assert(nda::is_complex_v<value_type>, "rspace_phase_factor: is_complex_v<T>.");
  if constexpr (MEM == HOST_MEMORY) {
    auto [ni,nj,nk] = f.shape(); 
    for(int i=0; i<ni; i++) { 
      double in = double(i)/double(ni);
      for(int j=0; j<nj; j++) {
        double jn = double(j)/double(nj);
        for(int k=0; k<nk; k++) {
          double kn = double(k)/double(nk);
          double Gr = G(0) * (in*lattv(0,0) + jn*lattv(1,0) + kn*lattv(2,0)) + 
                      G(1) * (in*lattv(0,1) + jn*lattv(1,1) + kn*lattv(2,1)) + 
                      G(2) * (in*lattv(0,2) + jn*lattv(1,2) + kn*lattv(2,2)); 
          f(i,j,k) = std::exp( value_type{0.0, Gr} );
        } 
      } 
    } 
  } else {
#if defined(ENABLE_DEVICE)
    kernels::device::rspace_phase_factor(lattv,G,f);
#else
    static_assert(MEM!=HOST_MEMORY,"Error: Device dispatch without device support.");
#endif
  }
}

/**
 * @param lattv - [INPUT] translational vector
 * @param G - [INPUT] G-vector in cartesian coordinates
 * @param shape - [INPUT] shape of the underlying fft grid
 * @param IPts - [INPUT] range of grid points in linearized fft indexing notation 
 * @param f - [OUTPUT] phase factor f(n) = exp(i * G * r(n)), 
 *                     where r(n) = (i, j, k) * lattv and r(n) is the nth vector in the range.
 * MAM: factor of 2*pi assumed included in definition of G
 *      e.g. kpts and recv are in cartesian coordinates with factor of 2*pi included...
 */
inline void rspace_phase_factor(nda::stack_array<double,3,3> const& lattv,
                                nda::ArrayOfRank<1> auto const& G,
                                nda::ArrayOfRank<1> auto const& shape,
                                nda::range rng,
                                nda::ArrayOfRank<1> auto && f)
{ 
  constexpr auto MEM = memory::get_memory_space<std::decay_t<decltype(f())>>();
  using value_type = typename std::decay_t<decltype(f)>::value_type;
  static_assert(nda::is_complex_v<value_type>, "rspace_phase_factor: is_complex_v<T>.");
  utils::check(rng.size() == f.size(), "Size mismatch");
  if constexpr (MEM == HOST_MEMORY) {
    auto F = utils::detail::rspace_phase_factor_mesh<decltype(f())>{
            long(rng.first()),nda::stack_array<long,3>{shape},
            nda::stack_array<double,3>{G},lattv,f()};
    std::ranges::for_each(nda::range(rng.size()),F);
  } else {
#if defined(ENABLE_DEVICE)
    kernels::device::rspace_phase_factor(lattv,G,shape,rng,f);
#else
    static_assert(MEM!=HOST_MEMORY,"Error: Device dispatch without device support.");
#endif 
  }
}


/**
* @param G - [INPUT] G-vector in crystal coordinates
* @param shape - [INPUT] shape of the underlying fft grid
* @param IPts - [INPUT] list of positions in crystal units (in compressed format, e.f. linearized fft indexing notation) 
* @param f - [OUTPUT] phase factor f(n) = exp(i * G * r(n)), 
*                     where r(n) = (i, j, k) * lattv and r(n) is the nth vector in the range.
*/
inline void rspace_phase_factor(nda::ArrayOfRank<1> auto const& G,
                                nda::ArrayOfRank<1> auto const& shape,
                                nda::ArrayOfRank<1> auto const& rn,
                                nda::ArrayOfRank<1> auto && f)
{
  constexpr auto MEM = memory::get_memory_space<std::decay_t<decltype(f())>>();
  using value_type = typename std::decay_t<decltype(f)>::value_type;
  static_assert(nda::is_complex_v<value_type>, "rspace_phase_factor: is_complex_v<T>.");
  utils::check(rn.size() == f.size(), "Size mismatch");
  auto rn_b = memory::to_memory_space<MEM>(rn());
  if constexpr (MEM == HOST_MEMORY) {
    auto F = utils::detail::rspace_phase_factor_crystal<decltype(rn_b()),decltype(f())>{
            nda::stack_array<long,3>{shape},nda::stack_array<double,3>{G},rn_b(),f()};
    std::ranges::for_each(nda::range(rn.size()),F);
  } else {
#if defined(ENABLE_DEVICE)
    kernels::device::rspace_phase_factor(G, shape, rn_b, f);
#else
    static_assert(MEM!=HOST_MEMORY,"Error: Device dispatch without device support.");
#endif 
  }
}

// This routine assumes that the node communicator in f_Rk lives within comm.
/**
 * Fourier transform kernel from k to R space with provided R vectors
 * @param Rpts_idx - [INPUT] R vectors in the unit of lattice vectors. Dimension: (nRpts, 3).
 * @param kpts - [INPUT] Target k-points in the unit of reciprocal lattice vectors. Dimension: (nkpts, 3).
 * @param lattv - [INPUT] Lattice vectors
 * @param f_kR - [OUTPUT] Fourier kernel. Dimension: (nRpts, nkpts)
 */
inline void k_to_R_coefficients(nda::ArrayOfRank<2> auto const& Rpts_idx,
                                nda::ArrayOfRank<2> auto const& kpts,
                                nda::stack_array<double,3,3> const& lattv,
                                nda::ArrayOfRank<2> auto &&f_Rk) {
  constexpr auto MEM = memory::get_memory_space<std::decay_t<decltype(f_Rk())>>();
  // temporary by-pass
  if constexpr (not (MEM==HOST_MEMORY)) {
    auto f_d = nda::to_host(f_Rk);
    k_to_R_coefficients(nda::to_host(Rpts_idx()),nda::to_host(kpts()),lattv,f_d);
    f_Rk() = f_d();
    return;
  }
  
  using value_type = typename std::decay_t<decltype(f_Rk)>::value_type;
  long nR = Rpts_idx.shape(0);
  long nk = kpts.shape(0);
  utils::check(f_Rk.shape() == std::array<long,2>{nR,nk},
               "k_to_r_coefficients: f_Rk shape mismatches. ({},{}), ({},{})",
               f_Rk.shape(0), f_Rk.shape(1), nR, nk);
  for (int i=0; i<nR; ++i) {
    long a = Rpts_idx(i,0);
    long b = Rpts_idx(i,1);
    long c = Rpts_idx(i,2);
    for (long q=0; q<nk; ++q) {
      double kR = kpts(q,0) * (a*lattv(0,0) + b*lattv(1,0) + c*lattv(2,0)) +
                  kpts(q,1) * (a*lattv(0,1) + b*lattv(1,1) + c*lattv(2,1)) +
                  kpts(q,2) * (a*lattv(0,2) + b*lattv(1,2) + c*lattv(2,2));
      f_Rk(i, q) = std::exp(value_type(0.0, -kR)) / nk;
    }
  }
}

// This routine assumes that the node communicator in f_Rk lives within comm.
// remove lattv when merged with new_symmetry branch!!!
template<class Communicator>
inline void k_to_R_coefficients(Communicator & comm, 
                                nda::range r_range,
                                nda::ArrayOfRank<2> auto const& kpts,
                                nda::stack_array<double,3,3> const& lattv,
                                nda::ArrayOfRank<1> auto const& fft_dim,
                                math::shm::SharedArray auto &&f_Rk) 
{
  long np = r_range.size();
  long nk = kpts.shape(0);
  long nnr = fft_dim(0)*fft_dim(1)*fft_dim(2);
  utils::check(r_range.first() >= 0 and r_range.last() <= nnr, 
      "k_to_r_coefficients: Range mismatch: ", r_range.first(),r_range.last());
  utils::check(nk <= nnr, "k_to_r_coefficients: fft_sim.size() ({}) < nkpts ({})",
               nnr, nk);
  utils::check(f_Rk.shape()[0] >= np and f_Rk.shape()[1] >= nk, 
      "k_to_r_coefficients: f_Rk shape mismatches. ({},{}), ({},{})", 
      f_Rk.shape()[0], f_Rk.shape()[1], np, nk);

  f_Rk.set_zero();
  auto f_loc = f_Rk.local()(nda::range(np),nda::range(nk));
  auto[r0, r1] = itertools::chunk_range(r_range.first(), r_range.last(), comm.size(), comm.rank());
  nda::range r_range_loc(r0,r1);
  // calculate f_Rk in local r_range
  if(r_range_loc.size() > 0) {
    long nx = fft_dim(0);
    long ny = fft_dim(1);
    long nz = fft_dim(2);
    nda::array<long, 2> Rpts_idx(r_range_loc.size(), 3);
    for ( auto [i, p]: itertools::enumerate(r_range_loc) ) {
      long a = p / (ny * nz);
      long b = (p / nz) % ny;
      long c = p % nz;
      if (a > nx / 2) a -= nx;
      if (b > ny / 2) b -= ny;
      if (c > nz / 2) c -= nz;
      Rpts_idx(i, 0) = a;
      Rpts_idx(i, 1) = b;
      Rpts_idx(i, 2) = c;
    }
    k_to_R_coefficients(Rpts_idx, kpts, lattv,
                        f_loc(nda::range(r0-r_range.first(), r1-r_range.first()), nda::range::all));
  }
  f_Rk.node_comm()->barrier();
  // reduce over comm 
  if (f_Rk.node_comm()->root()) {
    f_Rk.internode_comm()->all_reduce_in_place_n(f_loc.data(), np*f_Rk.shape()[1], std::plus<>{});
  }
  f_Rk.node_sync();
  comm.barrier();
}

template<class Communicator>
inline void k_to_R_coefficients(Communicator & comm,
                                nda::ArrayOfRank<2> auto const& Rpts_idx,
                                nda::ArrayOfRank<2> auto const& kpts,
                                nda::stack_array<double,3,3> const& lattv,
                                math::shm::SharedArray auto &&f_Rk)
{
  long nR = Rpts_idx.shape(0);
  nda::range R_range(nR);
  long nk = kpts.shape(0);
  utils::check(f_Rk.shape()[0] >= nR and f_Rk.shape()[1] >= nk,
               "k_to_r_coefficients: f_Rk shape mismatches. ({},{}), ({},{})",
               f_Rk.shape()[0], f_Rk.shape()[1], nR, nk);

  f_Rk.set_zero();
  auto f_loc = f_Rk.local()(nda::range(nR),nda::range(nk));
  auto[r0, r1] = itertools::chunk_range(R_range.first(), R_range.last(), comm.size(), comm.rank());
  nda::range R_range_loc(r0, r1);
  // calculate f_Rk in local r_range
  if(R_range_loc.size() > 0)
    k_to_R_coefficients(Rpts_idx(R_range_loc, nda::range::all), kpts, lattv,
                        f_loc(R_range_loc, nda::range::all));
  f_Rk.node_comm()->barrier();
  // reduce over comm
  if (f_Rk.node_comm()->root()) {
    f_Rk.internode_comm()->all_reduce_in_place_n(f_loc.data(), nR*f_Rk.shape()[1], std::plus<>{});
  }
  f_Rk.node_sync();
  comm.barrier();
}


// This routine assumes that the node communicator in f_kR lives within comm.
/**
 * Generalized Fourier transform kernel from R to k space with provided R vectors and the corresponding weights
 * @param Rpts_idx - [INPUT] R vectors in the unit of lattice vectors. Dimension: (nRpts, 3).
 * @param Rpts_weights - [INPUT] Weights for each R pointt. Dimension: (nRpts).
 * @param kpts - [INPUT] Target k-points in the unit of reciprocal lattice vectors. Dimension: (nkpts, 3).
 * @param lattv - [INPUT] Lattice vectors
 * @param f_kR - [OUTPUT] Fourier kernel. Dimension: (nkpts, nRpts)
 */
inline void R_to_k_coefficients(nda::ArrayOfRank<2> auto const& Rpts_idx,
                                nda::ArrayOfRank<1> auto const& Rpts_weights,
                                nda::ArrayOfRank<2> auto const& kpts,
                                nda::stack_array<double,3,3> const& lattv,
                                nda::ArrayOfRank<2> auto &&f_kR) {
  using value_type = typename std::decay_t<decltype(f_kR)>::value_type;
  constexpr auto MEM = memory::get_memory_space<std::decay_t<decltype(f_kR())>>();
  // temporary by-pass
  if constexpr (not (MEM==HOST_MEMORY)) {
    auto f_d = nda::to_host(f_kR);
    R_to_k_coefficients(nda::to_host(Rpts_idx()),nda::to_host(Rpts_weights()),nda::to_host(kpts()),lattv,f_d);
    f_kR() = f_d();
    return;
  }

  long nR = Rpts_idx.shape(0);
  long nk = kpts.shape(0);
  utils::check(f_kR.shape() == std::array<long,2>{nk,nR},
               "R_to_k_coefficients: f_kR shape mismatches. ({},{}), ({},{})",
               f_kR.shape(0), f_kR.shape(1), nk, nR);

  for (long q = 0; q < nk; ++q) {
    for (long R=0; R<nR; ++R) {
      long a = Rpts_idx(R, 0);
      long b = Rpts_idx(R, 1);
      long c = Rpts_idx(R, 2);
      double kR = kpts(q,0) * (a*lattv(0,0) + b*lattv(1,0) + c*lattv(2,0)) +
                  kpts(q,1) * (a*lattv(0,1) + b*lattv(1,1) + c*lattv(2,1)) +
                  kpts(q,2) * (a*lattv(0,2) + b*lattv(1,2) + c*lattv(2,2));
      f_kR(q, R) = std::exp(value_type(0.0, kR)) / Rpts_weights(R);
    }
  }
}

// This routine assumes that the node communicator in f_kR lives within comm.
// remove lattv when merged with new_symmetry branch!!!
template<class Communicator>
inline void R_to_k_coefficients(Communicator & comm,
                                nda::range r_range,
                                nda::ArrayOfRank<2> auto const& kpts,
                                nda::stack_array<double,3,3> const& lattv,
                                nda::ArrayOfRank<1> auto const& fft_dim,
                                math::shm::SharedArray auto &&f_kR)
{ 
  long nR = r_range.size();
  long nk = kpts.shape(0);
  long nnr = fft_dim(0)*fft_dim(1)*fft_dim(2);
  utils::check(r_range.first() >= 0 and r_range.last() <= nnr, 
      "R_to_k_coefficients: Range mismatch: ", r_range.first(),r_range.last());
  utils::check(f_kR.shape()[0] >= nk and f_kR.shape()[1] >= nR,
      "R_to_k_coefficients: f_kR shape mismatches. ({},{}), ({},{})",
      f_kR.shape()[0], f_kR.shape()[1], nk, nR);
  
  f_kR.set_zero();
  auto f_loc = f_kR.local()(nda::range(nk),nda::range(nR));
  auto[r0, r1] = itertools::chunk_range(r_range.first(), r_range.last(), comm.size(), comm.rank());
  nda::range r_range_loc(r0,r1);
  // calculate f_kR in local r_range
  if(r_range_loc.size() > 0) {
    nda::array<long ,2> Rpts_idx(r_range_loc.size(), 3);
    nda::array<long, 1> Rpt_weights(r_range_loc.size());
    Rpt_weights() = 1;
    long nx = fft_dim(0);
    long ny = fft_dim(1);
    long nz = fft_dim(2);
    for ( auto [i, p]: itertools::enumerate(r_range_loc) ) {
      long a = p / (ny * nz);
      long b = (p / nz) % ny;
      long c = p % nz;
      if (a > nx / 2) a -= nx;
      if (b > ny / 2) b -= ny;
      if (c > nz / 2) c -= nz;
      Rpts_idx(i, 0) = a;
      Rpts_idx(i, 1) = b;
      Rpts_idx(i, 2) = c;
    }

    R_to_k_coefficients(Rpts_idx, Rpt_weights, kpts, lattv,
                        f_loc(nda::range::all, nda::range(r0-r_range.first(), r1-r_range.first())));
  }
  f_kR.node_comm()->barrier();
  // reduce over comm 
  if (f_kR.node_comm()->root()) {
    f_kR.internode_comm()->all_reduce_in_place_n(f_loc.data(), nk*f_kR.shape()[1], std::plus<>{});
  }
  f_kR.node_sync();
  comm.barrier();
}

template<class Communicator>
inline void R_to_k_coefficients(Communicator & comm,
                                nda::ArrayOfRank<2> auto const& Rpt_idx,
                                nda::ArrayOfRank<1> auto const& Rpt_weights,
                                nda::ArrayOfRank<2> auto const& kpts,
                                nda::stack_array<double,3,3> const& lattv,
                                math::shm::SharedArray auto &&f_kR)
{
  long nR = Rpt_idx.shape(0);
  nda::range R_range(nR);
  long nk = kpts.shape(0);
  utils::check(f_kR.shape()[0] >= nk and f_kR.shape()[1] >= nR,
               "R_to_k_coefficients: f_kR shape mismatches. ({},{}), ({},{})",
               f_kR.shape()[0], f_kR.shape()[1], nk, nR);

  f_kR.set_zero();
  auto f_loc = f_kR.local()(nda::range(nk),nda::range(nR));
  auto[r0, r1] = itertools::chunk_range(R_range.first(), R_range.last(), comm.size(), comm.rank());
  nda::range R_range_loc(r0,r1);
  // calculate f_kR in local r_range
  if(R_range_loc.size() > 0)
    R_to_k_coefficients(Rpt_idx(R_range_loc, nda::range::all), Rpt_weights(R_range_loc), kpts,lattv,
                        f_loc(nda::range::all,nda::range(r0-R_range.first(),r1-R_range.first())));
  f_kR.node_comm()->barrier();
  // reduce over comm
  if (f_kR.node_comm()->root()) {
    f_kR.internode_comm()->all_reduce_in_place_n(f_loc.data(), nk*f_kR.shape()[1], std::plus<>{});
  }
  f_kR.node_sync();
  comm.barrier();
}

/**
 * Calculate kpoint mapping between two kpts lists
 * @param kp_map     - [OUTPUT] kpts_crys1[ik] = kpts_crys2[kp_map[ik]]
 * @param kpts_crys1 - [INPUT] kpt list 1
 * @param kpts_crys2 - [INPUT] kpt list 2
 */
inline void calculate_kp_map(nda::ArrayOfRank<1> auto &&kp_map,
                             nda::ArrayOfRank<2> auto const& kpts_crys1,
                             nda::ArrayOfRank<2> auto const& kpts_crys2,
                             double threshold=1e-4) {
  utils::check(kp_map.shape(0) == kpts_crys1.shape(0) and kpts_crys1.shape(0)==kpts_crys2.shape(0),
               "calculate_kp_map: inconsistent nkpts between kpts_crys1 and kpts_crys2");
  utils::check(kpts_crys1.shape(1)==3 and kpts_crys2.shape(1)==3, "calculate_kp_map: kpts_crys.shape(1) != 3");

  nda::stack_array<double, 3> kp;
  auto comp = [&kp,&threshold](nda::ArrayOfRank<1> auto&& a) {
    // doing this by hand, not sure what's a better way
    double di = std::abs(a(0)-kp(0));
    if( std::abs(di) < threshold ) di = 0.0;
    if( std::abs(di-1.0) < threshold ) di = 0.0;
    if( std::abs(di-2.0) < threshold ) di = 0.0;
    if( std::abs(di-3.0) < threshold ) di = 0.0;
    double dj = std::abs(a(1)-kp(1));
    if( std::abs(dj) < threshold ) dj = 0.0;
    if( std::abs(dj-1.0) < threshold ) dj = 0.0;
    if( std::abs(dj-2.0) < threshold ) dj = 0.0;
    if( std::abs(dj-3.0) < threshold ) dj = 0.0;
    double dk = std::abs(a(2)-kp(2));
    if( std::abs(dk) < threshold ) dk = 0.0;
    if( std::abs(dk-1.0) < threshold ) dk = 0.0;
    if( std::abs(dk-2.0) < threshold ) dk = 0.0;
    if( std::abs(dk-3.0) < threshold ) dk = 0.0;
    return di + dj + dk < 1e-12;
  };

  kp_map() = -1;
  long nkpts = kp_map.shape(0);
  for (size_t ik = 0; ik < nkpts; ++ik) {
    kp = kpts_crys1(ik,nda::range::all);
    for (size_t ikk = 0; ikk < nkpts; ++ikk) {
      auto is_same = comp(kpts_crys2(ikk,nda::range::all));
      if (is_same) kp_map(ik) = ikk;
    }
    if (kp_map(ik) == -1) {
      utils::check(false, "calculate_kp_map: fail to find kpts({}) = ({}, {}, {})", ik, kp(0), kp(1), kp(2));
    }
  }
}

bool equivalent_k(::nda::ArrayOfRank<1> auto&& k1, ::nda::ArrayOfRank<1> auto && k2, double threshold = 1e-6)
{
  double di = std::abs(k1(0)-k2(0));
  double dj = std::abs(k1(1)-k2(1));
  double dk = std::abs(k1(2)-k2(2));
  di -= std::floor(di); if( std::abs(di-1.0) < threshold ) di = 0.0;
  dj -= std::floor(dj); if( std::abs(dj-1.0) < threshold ) dj = 0.0;
  dk -= std::floor(dk); if( std::abs(dk-1.0) < threshold ) dk = 0.0;
  return di + dj + dk < threshold;
}

} // utils

#endif
