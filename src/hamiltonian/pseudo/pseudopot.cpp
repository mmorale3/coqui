/**
 * ==========================================================================
 * CoQuí: Correlated Quantum ínterface
 *
 * Copyright (c) 2022-2025 Simons Foundation & The CoQuí developer team
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ==========================================================================
 */


#include <fstream>
#include <filesystem>

#include "configuration.hpp"
#include "IO/app_loggers.h"
#include "arch/arch.h"
#include "utilities/check.hpp"
#include "utilities/fortran_utilities.h"
#include "utilities/kpoint_utils.hpp"
#include "mpi3/environment.hpp"
#include "mpi3/communicator.hpp"
#include "h5/h5.hpp"
#include "nda/nda.hpp"
#include "nda/h5.hpp"
#include "nda/tensor.hpp"
#include "numerics/distributed_array/nda.hpp"
#include "numerics/shared_array/nda.hpp"
#include "utilities/qe_utilities.hpp"
#include "utilities/mpi_context.h"
#include "mean_field/MF.hpp"
#include "mean_field/distributed_orbital_readers.hpp"
#include "hamiltonian/add_vloc.hpp"
#include "hamiltonian/v_h.hpp"
#include "hamiltonian/pseudo/pseudopot.h"
#include "hamiltonian/pseudo/pseudopot_to_h5.hpp"
#include "numerics/nda_functions.hpp"

namespace hamilt 
{

using utils::mpi_context_t;
using math::shm::make_shared_array;
using boost::mpi3::communicator;
using boost::mpi3::shared_communicator;

template<typename MF_t>
pseudopot::pseudopot(MF_t &mf, std::string const filename) :
  mpi(mf.mpi()),
  fft_mesh(mf.fft_grid_dim()),      // customize grid!!!
  nnr(mf.nnr()),
  recv(mf.recv()),
  lattv(mf.lattv()),
  nkpts(mf.nkpts()),
  nkpts_ibz(mf.nkpts_ibz()),
  kpts(mf.kpts()),
  kpts_crys(mf.kpts_crystal()),
  kp_to_ibz(mf.kp_to_ibz()),
  kp_trev(mf.kp_trev()),
  symm_list(mf.symm_list()),
  kp_symm(mf.kp_symm()),
  Pskna(make_shared_array<nda::array_view<ComplexType,4>>(*mpi,{1,1,1,1})),   // resize later
  Dnn(make_shared_array<nda::array_view<ComplexType,3>>(*mpi,{1,1,1})),       // resize later
  swfc_to_rho(detail::make_wfc_to_rho(*mpi,mf,fft_mesh)),
  svloc(make_shared_array<nda::array_view<ComplexType,3>>(*mpi,{1,1,1})),            // resize later
  svsc(make_shared_array<nda::array_view<ComplexType,3>>(*mpi,{1,1,1})),  // resize later
  qgm(make_shared_array<nda::array_view<ComplexType,3>>(*mpi,{1,1,1}))             // resize later
{ 
  if( mf.mf_type() == mf::pyscf_source ) { 

    // nothing to do, evaluation routines should not be called! 
    ptype = pp_FILE_t;
    return ;

  } else { 

    // remember input type
    input_file_type = mf.input_file_type();        

    app_log(2,"************************************************");
    app_log(2," Initializing External Potential: ");
    app_log(2,"************************************************");
#if defined(ENABLE_DEVICE)
    app_log(2,"  Device support enabled.");
#endif
    if(filename != "" or mf.input_file_type() == mf::h5_input_type) {
      input_file_name = (filename != ""?filename:mf.filename()); 
      utils::check(std::filesystem::exists(input_file_name), "Error: Missing file: {}",input_file_name); 
      h5::file file;
      try {
        file = h5::file(input_file_name, 'r');
      } catch(...) {
        APP_ABORT("Failed to open h5 file: {}, mode:r",input_file_name);
      }
      h5::group grp(file);
      read_vnl_h5(mf,grp);
    } else if( mf.input_file_type() == mf::xml_input_type and mf.mf_type() == mf::qe_source ) {
      // read ASCII and binary files generated by QE::pp.x and QE::pw2bgw.x
      input_file_name = mf.outdir();
      read_vnl_pw2bgw(mf,mf.outdir());
    } else
      utils::check(false,"Error in pseudopot:: Unknown input file type/mf object combination.");

    double x = 16.0/1024.0/1024.0/1024.0;
    app_log(2,"\n Memory usage: ");
    app_log(2,"   Overlaps:                      {} MB",Pskna.local().size()*x);  
    app_log(2,"   Dion:                          {} MB",Dnn.local().size()*x);  
    if(ptype ==  pp_uspp_t)
      app_log(2,"   Augmentation Functions:        {} MB",qgm.local().size()*x);  
    if(ptype ==  pp_paw_t)
      app_log(2,"   Atomic terms:        {} MB",0);  
    app_log(2,"************************************************\n");

  } 
}

// MAM: pw2bgw only allows NCPP psp
template<typename MF_t>
void pseudopot::read_vnl_pw2bgw(MF_t &mf, std::string outdir) 
{
  utils::check(mf.npol()==1, "Error in read_vnl_pw2bgw: Noncollinear not yet supported.");
  std::string fname = outdir + "/VKB";
  decltype(nda::range::all) all;
  int sz = fname.size();
  int npwx,nkb,nat,nhm,nsp,ierr;
  auto wfc_g = mf.wfc_truncated_grid();
  long ngm = wfc_g->size();
  auto fft2gv = wfc_g->fft_to_gv();
  long wfc_nnr = wfc_g->nnr();
  if(mpi->comm.root()) {
    int nspin_,nk_; 
    utils::check(std::filesystem::exists(fname), "Error: Missing file: {}",fname); 
    FC_read_pw2bgw_vkbg_header(fname.c_str(), sz, nspin_, nkb, npwx, nk_, nat, nsp, nhm,ierr);
    utils::check(ierr==0, "Error reading QE::pw2bgw vkbg file (header info).");
    utils::check(mf.nkpts_ibz()==nk_,"pseudopot: Data mismatch.");
    utils::check(mf.nspin()==nspin_,"pseudopot: Data mismatch.");
    utils::check(ngm>=npwx,"pseudopot: Data mismatch.");

    app_log(2,"  input type: qe::pp/qe::pw2bgw");
    app_log(2,"  type: NCPP");
    app_log(2,"  # of species: {}",nsp);
    app_log(2,"  # of atoms: {}",nat);
    app_log(2,"  max # of projectors per atom: {}",nhm);
    app_log(2,"  # of projectors: {}",nkb);
  } 
  long nk = mf.nkpts_ibz();
  long nbnd = mf.nbnd();

  mpi->comm.broadcast_value(nkb);
  mpi->comm.broadcast_value(nat);
  mpi->comm.broadcast_value(nsp);
  mpi->comm.broadcast_value(nhm);
  mpi->comm.broadcast_value(npwx);

  ityp.resize(nat);
  nh.resize(nsp);
  nh()=0;
  ityp()=0;
   
  nda::array<int,1> npw(nk);
  sarray_t<nda::array_view<int,3>> miller(*mpi,{nk,npwx,3}); 
  sarray_t<nda::array_view<ComplexType,3>> vkb(*mpi,{nk,nkb,ngm}); 
  Dnn = sarray_t<nda::array_view<ComplexType,3>>(*mpi,{nsp,nhm,nhm}); 

  if(mpi->comm.root()) {
    int msz = int(nk*npwx*3), vsz=int(nk*nkb*npwx), Dsz = int(nspin*nsp*nhm*nhm);
    int k0=0, k1=nk;
    nda::array<double,4> Dnn_r(nspin,nsp,nhm,nhm); 
    if(npwx != ngm) {
      nda::array<ComplexType,3> vkb_r(nk,nkb,npwx);
      FC_read_pw2bgw_vkbg(fname.c_str(), sz, k0, k1, ityp.data(), nat, 
        nh.data(), nsp, npw.data(), nk, 
        Dnn_r.data(), Dsz, miller.local().data(), msz, vkb_r.data(), vsz, ierr);
      vkb.local()(all,all,nda::range(npwx)) = vkb_r();
    } else {
      FC_read_pw2bgw_vkbg(fname.c_str(), sz, k0, k1, ityp.data(), nat, 
        nh.data(), nsp, npw.data(), nk, 
        Dnn_r.data(), Dsz, miller.local().data(), msz, vkb.local().data(), vsz, ierr);
    }
    // modify in non-collinear case
    for(int i=0; i<nsp; i++)
      Dnn.local()(i,nda::range(nh(i)),nda::range(nh(i))) = Dnn_r(0,i,nda::range(nh(i)),nda::range(nh(i)));
    // to Hartree
    nda::tensor::scale(ComplexType(0.5),Dnn.local());
    utils::check(ierr==0, "Error reading QE::pw2bgw vkbg file (arrays) - ierr:{}",ierr);
  }

  mpi->comm.broadcast_n(npw.data(),nk);
  mpi->comm.broadcast_n(ityp.data(),nat);
  mpi->comm.broadcast_n(nh.data(),nsp);
  
  if(mpi->node_comm.root()) {
    mpi->internode_comm.broadcast_n(miller.local().data(),miller.size());
    mpi->internode_comm.broadcast_n(vkb.local().data(),vkb.size());
    mpi->internode_comm.broadcast_n(Dnn.local().data(),Dnn.size());
  }
  mpi->comm.barrier();

  // mapping from miller indices to wfc_g
  sarray_t<nda::array_view<long,2>> sk2g(*mpi,{nk,npwx});
  auto k2g = sk2g.local();  
  auto miller_loc = miller.local();

  int rank = mpi->comm.rank();
  int np = mpi->comm.size();
  // setup index mappings
  { 
    long NX = wfc_g->mesh(0), NY = wfc_g->mesh(1), NZ = wfc_g->mesh(2);
    for( int ik=0; ik<nk; ik++ ) {
      if(  ik%np != rank ) continue;
      auto mill = miller_loc(ik,nda::range(npw(ik)),all);
      // map miller index to wfc_g truncated grid
      for( int i=0; i<npw(ik); i++ ) {
        long n1 = mill(i,0); if(n1<0) n1 += NX;
        long n2 = mill(i,1); if(n2<0) n2 += NY;
        long n3 = mill(i,2); if(n3<0) n3 += NZ;
        utils::check(n1 < NX, "read_vnl_h5: Index out of range. i:{}, n:{}, NX:{}",i,n1,NX);
        utils::check(n2 < NY, "read_vnl_h5: Index out of range. i:{}, n:{}, NY:{}",i,n2,NY);
        utils::check(n3 < NZ, "read_vnl_h5: Index out of range. i:{}, n:{}, NZ:{}",i,n3,NZ);
        long N = (n1*NY + n2)*NZ + n3;
        utils::check( N >= 0 and N < wfc_nnr, "read_vnl_h5: Index out of range. N:{}, nnr:{}",N,wfc_nnr);
        k2g(ik,i) = fft2gv(N);  
        utils::check( k2g(ik,i) >= 0 and k2g(ik,i) < ngm, "read_vnl_xml: Index not mapped in truncated grid. ");
      }
    }
    mpi->comm.barrier();
    if(mpi->node_comm.root()) 
      mpi->internode_comm.all_reduce_in_place_n(k2g.data(),k2g.size(),std::plus<>{});
    mpi->comm.barrier();
  }
  miller = sarray_t<nda::array_view<int,3>>(*mpi,{1,1,1}); 

  // setup offset list
  ofs.resize(nat);
  long iofs=0;
  for( auto [i,n] : itertools::enumerate(nh) )
    for( auto iat : nda::range(nat) )
      if(ityp(iat) == i) {
        ofs(iat) = iofs;
        iofs += n;  
      }

  // calculate projectors
  Pskna = sarray_t<nda::array_view<ComplexType,4>>(*mpi,{nspin,nk,npol*long(nkb),nbnd}); 
  auto Ploc = Pskna.local();
  auto vkloc = vkb.local();  // MAM: vkb was conjugated above !!!
  nda::array<ComplexType,2> Orb(8,wfc_nnr);
  nda::array<ComplexType,2> buff(nkb,wfc_nnr);
  long iskb = 0;
  for( int is = 0; is < nspin; ++is ) 
    for( int ik = 0; ik < nk; ++ik )  
      for( int ib = 0; ib < nbnd; ib+=8, ++iskb ) { 
        if( iskb%np != rank ) continue; 
        int nb_ = std::min(8,int(nbnd)-ib);
        // (n,a) = conj[ (n,G) ] * T(a,G)
        mf.get_orbital_set('w', is, ik, nda::range(ib,ib+nb_), Orb(nda::range(nb_),all)); 
        buff() = ComplexType(0.0);
        for( auto [in,n] : itertools::enumerate(k2g(ik,nda::range(npw(ik)))) )
          buff(all,n) = nda::conj(vkloc(ik,all,in));
        nda::blas::gemm(ComplexType(1.0),buff, nda::transpose(Orb(nda::range(nb_),all)),
                        ComplexType(0.0),Ploc(is,ik,all,nda::range(ib,ib+nb_)));  
      }
  mpi->comm.barrier();
  if(mpi->node_comm.root()) {
    mpi->internode_comm.all_reduce_in_place_n(Ploc.data(),Ploc.size(),std::plus<>{});
  }
  mpi->comm.barrier();

  // local and self-consistent potentials
  spinorbit_loc = false;
  svloc = sarray_t<nda::array_view<ComplexType,3>>(*mpi,{nspin,1,nnr}); 
  svsc = sarray_t<nda::array_view<ComplexType,3>>(*mpi,{nspin,npol*npol,nnr}); 
  if(mpi->comm.root()) {
    if(std::filesystem::exists(outdir+"/VSC")) {
      nda::array<ComplexType,1> v;
      utils::read_qe_plot_file(1,outdir+"/VSC",mf.fft_grid_dim(),v);
      // MAM: transform to nnr grid...  spin/polarization dependence???
      // this is wrong if nspin or npol > 1!
      // ignore for now since this is not used anywhere!
      utils::check(v.extent(0) == nnr, "Error: Dimension mismatch");
      for(int is=0; is<nspin; is++)
        svsc.local()(is,0,all) = v();
      // to Hartree
      nda::tensor::scale(ComplexType(0.5),svsc.local());
    } else {
// MAM: no direct evaluation of Fock matrix, so message is irrelevant. Reenable is direct evaluation is 
//      implemented, and only message if call is made, since it is rare to do this.
//      app_warning(stars+" Missing VSC file!!! Direct evaluation of Fock matrix will be incorrect!"+stars);
    }
    if(std::filesystem::exists(outdir+"/VLTOT")) { 
      nda::array<ComplexType,1> v;
      utils::read_qe_plot_file(2,outdir+"/VLTOT",mf.fft_grid_dim(),v);
      // MAM: transform to nnr grid...
      utils::check(v.extent(0) == nnr, "Error: Dimension mismatch");
      for(int is=0; is<nspin; is++)
        svloc.local()(is,0,all) = v();
      // to Hartree
      nda::tensor::scale(ComplexType(0.5),svloc.local());
    } else {
#if defined(ALLOW_MISSING_VLTOT)
      app_warning("*************************************************************************");
      app_warning("*************************************************************************");
      app_warning("*************************************************************************");
      app_warning("  Missing VLTOT file!!! Non-interacting Hamiltonian could be incorrect!!!");
      app_warning("*************************************************************************");
      app_warning("*************************************************************************");
      app_warning("*************************************************************************");
#else
      APP_ABORT("Missing VLTOT file!!! Should exist in outdir:{}");
#endif
    }
  }

  if(mpi->node_comm.root()) {
    mpi->internode_comm.broadcast_n(svsc.local().data(),svsc.size());
    mpi->internode_comm.broadcast_n(svloc.local().data(),svloc.size());
  }
  mpi->comm.barrier();

}

template<typename MF_t>
void pseudopot::read_vnl_h5(MF_t &mf, h5::group& grp0)
{
  using nda::range;
  decltype(range::all) all;
  std::string type(""); 

  h5::group grp1 = grp0.open_group("Hamiltonian");
  h5::h5_read_attribute(grp1, "pp_type", type);

  app_log(2,"  input type: coqui::h5");
  if(type == "ncpp") {
    ptype = pp_ncpp_t;
    app_log(2,"  type: NCPP");
  } else if(type == "uspp") {
    ptype = pp_uspp_t;
    app_log(2,"  type: USPP");
  } else if(type == "paw") {
    ptype = pp_paw_t;
    app_log(2,"  type: PAW");
  } else {
    APP_ABORT("Invalid pp_type: {}",type);
  }

  h5::group grp = grp1.open_group(type);

  int nk, npwx;
  h5::h5_read_attribute(grp,"number_of_nspins",nspin);
  h5::h5_read_attribute(grp,"number_of_polarizations",npol);
  h5::h5_read_attribute(grp,"number_of_kpoints",nk);
  h5::h5_read_attribute(grp,"max_npw",npwx);
  int lspinorb;
  h5::h5_read_attribute(grp,"lspinorbit_nl",lspinorb);
  spinorbit_nl = (lspinorb!=0);
  h5::h5_read_attribute(grp,"lspinorbit_loc",lspinorb);
  spinorbit_loc = (lspinorb!=0);

  utils::check(nspin == mf.nspin(), "Error in pseudopot::read_vnl_h5: Inconsistent nspin.");
  utils::check(npol == mf.npol(), "Error in pseudopot::read_vnl_h5: Inconsistent npol:{} (mf:{})",npol,mf.npol());
  utils::check(nk == mf.nkpts_ibz(), "Error in pseudopot::read_vnl_h5: Inconsistent nkpts.");
  utils::check(mf.wfc_truncated_grid()->size() >= npwx,
               "Error in pseudopot::read_vnl_h5: ngm < max_npw");
  utils::check(spinorbit_nl == mf.spinorbit(), "Error in pseudopot::read_vnl_h5: Inconsistent spinorbit.");

  int nat, nsp, nkb, nhm;
  h5::h5_read_attribute(grp,"number_of_atoms",nat);
  h5::h5_read_attribute(grp,"number_of_species",nsp);
  h5::h5_read_attribute(grp,"total_num_of_proj",nkb);
  h5::h5_read_attribute(grp,"max_proj_per_atom",nhm);

  app_log(2,"  # of species: {}",nsp);
  app_log(2,"  # of atoms: {}",nat);
  app_log(2,"  max # of projectors per atom: {}",nhm);
  app_log(2,"  # of projectors: {}",nkb);
  app_log(2,"  # of polarizations: {}",npol);
  app_log(2,"  spin orbit: {}",spinorbit_nl);

  int nbnd = mf.nbnd();
  int rank = mpi->comm.rank();
  int np = mpi->comm.size();
  nda::array<int,1> npw(nk);

  // node number 
  int inode;
  if( mpi->node_comm.root() ) inode = mpi->internode_comm.rank();
  mpi->node_comm.broadcast_n(&inode,1,0);
  int nnodes = inode+1; 
  mpi->comm.all_reduce_in_place_n(&nnodes,1,mpi3::max<>{});

  // local potential
  svloc = sarray_t<nda::array_view<ComplexType,3>>(*mpi,{nspin,(spinorbit_loc?npol*npol:1),nnr});
  svsc = sarray_t<nda::array_view<ComplexType,3>>(*mpi,{nspin,npol*npol,nnr});
  if(mpi->comm.root()) {
    int ngm;
    h5::h5_read_attribute(grp,"ngm",ngm);
    nda::array<long,1> k2g(ngm); 

    {
      nda::array<int,2> mill_g(ngm,3); 
      nda::h5_read(grp,"miller_g",mill_g);
      utils::generate_k2g(mill_g,k2g,mf.fft_grid_dim());
    }


    // vsc
    { 
      auto vr = svsc.local();
      auto vr2d = nda::reshape(vr,std::array<long,2>{nspin*npol*npol,nnr});
      auto v4D = nda::reshape(vr,std::array<long,4>{nspin*npol*npol,fft_mesh(0),fft_mesh(1),fft_mesh(2)});
      math::nda::fft<true> F(v4D);

      nda::array<ComplexType,3> vl(nspin, npol*npol, ngm); 
      auto vl2d = nda::reshape(vl,std::array<long,2>{nspin*npol*npol,ngm});
      nda::h5_read(grp,"scf_local_potential",vl); 
      utils::check(vl.shape() == std::array<long,3>{nspin,npol*npol,ngm}, "Shape mismatch: scf_local_potential");
      vr() = ComplexType(0.0);
      nda::copy_select(true,1,k2g,ComplexType(1.0),vl2d,ComplexType(0.0),vr2d);
      F.backward(v4D);
    } 
 
    // vloc
    if(spinorbit_loc) {
      auto vr = svloc.local();
      auto vr2d = nda::reshape(vr,std::array<long,2>{nspin*npol*npol,nnr});
      auto v4D = nda::reshape(vr,std::array<long,4>{nspin*npol*npol,fft_mesh(0),fft_mesh(1),fft_mesh(2)});
      math::nda::fft<true> F(v4D);

      nda::array<ComplexType,3> vl(nspin, npol*npol, ngm); 
      auto vl2d = nda::reshape(vl,std::array<long,2>{nspin*npol*npol,ngm});
      vl() =  ComplexType(0.0);
      nda::h5_read(grp,"pp_local_component_nc",vl);
      utils::check(vl.shape() == std::array<long,3>{nspin,npol*npol,ngm}, 
                   "Shape mismatch: pp_local_component");
      vr() = ComplexType(0.0);
      nda::copy_select(true,1,k2g,ComplexType(1.0),vl2d,ComplexType(0.0),vr2d); 
      F.backward(v4D);
    } else {
      auto vr = svloc.local();
      auto vr2d = nda::reshape(vr,std::array<long,2>{nspin,nnr});
      auto v4D = nda::reshape(vr,std::array<long,4>{nspin, fft_mesh(0),fft_mesh(1),fft_mesh(2)});
      math::nda::fft<true> F(v4D);

      nda::array<ComplexType,1> vl_(ngm); 
      nda::h5_read(grp,"pp_local_component",vl_);
      utils::check(vl_.shape() == std::array<long,1>{ngm}, "Shape mismatch: pp_local_component");
      vr() = ComplexType(0.0);
      nda::copy_select(true,k2g,ComplexType(1.0),vl_,ComplexType(0.0),vr2d(0,all));
      for(int is=1; is<nspin; is++)
        vr(is, 0, all) = vr(0, 0, all);
      F.backward(v4D);
    }

    // to Hartree unit
    nda::tensor::scale(ComplexType(0.5),svsc.local());
    nda::tensor::scale(ComplexType(0.5),svloc.local());
  }
  if(mpi->node_comm.root()) { 
    mpi->internode_comm.broadcast_n(svsc.local().data(),svsc.size(),0);
    mpi->internode_comm.broadcast_n(svloc.local().data(),svloc.size(),0);
  }
  mpi->comm.barrier();

  nh.resize(nsp);
  ityp.resize(nat);
  ofs.resize(nat);
  // for PAW/USPP: 
  // ijtoh.resize(nhm,nhm,nsp);
  
  nda::h5_read(grp,"proj_per_atom",nh);
  nda::h5_read(grp,"projector_offset",ofs);
  //nda::h5_read(grp,"ijtoh",ijtoh);
  nda::h5_read(grp,"npw",npw);
  nda::h5_read(grp,"atomic_id",ityp);
  //ityp = ityp-1;  
  // MAM: temporary fix until new pw2coqui.f90 is in place, remove eventually
  // should be 0-based indexing always
  {
    int id_min = *std::min_element(ityp.begin(),ityp.end());
    utils::check(id_min==0 or id_min==1,
                 "qe_interface::read_h5 Invalid atomic_ids array: min id:{}.",id_min);
    ityp() -= id_min;
  }

  // Dnn = dvan
  Dnn = sarray_t<nda::array_view<ComplexType,3>>(*mpi,{nsp,nhm*npol,nhm*npol});
  mpi->node_comm.barrier();

  if(mpi->node_comm.root())
  {
    if(ptype == pp_ncpp_t) {
      if(spinorbit_nl) {
        nda::array<ComplexType,4> Dnn_c(nsp,npol*npol,nhm,nhm); 
        nda::h5_read(grp,"dion_so",Dnn_c);
        auto Dloc = Dnn.local();
        // MAM: dion_so needs to be transposed, since it was written in column-major
        for( int s=0; s<nsp; ++s )
          for( int p=0; p<npol; ++p )
            for( int q=0; q<npol; ++q )
              for( int n=0; n<nhm; ++n )
                for( int m=0; m<nhm; ++m )
                  // Dloc(s,np,mq) = transpose( Dnn_c(s,pq,n,m) )
                  Dloc(s,n*npol+p,m*npol+q) = Dnn_c(s,p*npol+q,m,n);
      } else {
        nda::array<double,3> Dnn_r(nsp,nhm,nhm); 
        nda::h5_read(grp,"dion",Dnn_r);
        auto Dloc = Dnn.local();
        Dloc() = ComplexType(0.0);
        for( int s=0; s<nsp; ++s )
          for( int p=0; p<npol; ++p )
            for( int n=0; n<nhm; ++n )
              for( int m=0; m<nhm; ++m )
                Dloc(s,n*npol+p,m*npol+p) = Dnn_r(s,n,m);
      }
      nda::tensor::scale(ComplexType(0.5),Dnn.local());
    } else
      utils::check(false,"finish");
  }
  mpi->node_comm.barrier();

  // calculate projectors
  sarray_t<nda::array_view<long,2>> sk2g(*mpi,{nk,npwx});
  auto k2g = sk2g.local();
  auto wfc_g = mf.wfc_truncated_grid();  
  long ngm = wfc_g->size();
  auto fft2gv = wfc_g->fft_to_gv();
  long wfc_nnr = wfc_g->nnr(); 

  // setup index mappings
  {
    long NX = wfc_g->mesh(0), NY = wfc_g->mesh(1), NZ = wfc_g->mesh(2);
    for( int ik=0; ik<nk; ik++ ) {
      if(  ik%np != rank ) continue;
      nda::array<int,2> mill(npw(ik),3);
      nda::h5_read(grp,"miller_k"+std::to_string(ik),mill);
      // map miller index to wfc_g truncated grid
      for( int i=0; i<npw(ik); i++ ) {
        long n1 = mill(i,0); if(n1<0) n1 += NX;
        long n2 = mill(i,1); if(n2<0) n2 += NY;
        long n3 = mill(i,2); if(n3<0) n3 += NZ;
        utils::check(n1 < NX, "read_vnl_h5: Index out of range. i:{}, n:{}, NX:{}",i,n1,NX);
        utils::check(n2 < NY, "read_vnl_h5: Index out of range. i:{}, n:{}, NY:{}",i,n2,NY);
        utils::check(n3 < NZ, "read_vnl_h5: Index out of range. i:{}, n:{}, NZ:{}",i,n3,NZ);
        long N = (n1*NY + n2)*NZ + n3;
        utils::check( N >= 0 and N < wfc_nnr, "read_vnl_h5: Index out of range. N:{}, nnr:{}",N,wfc_nnr);
        k2g(ik,i) = fft2gv(N); 
        utils::check( k2g(ik,i) >= 0 and k2g(ik,i) < ngm, "read_vnl_h5: Index not mapped in truncated grid. "); 
      } 
    }
    mpi->comm.barrier();
    if(mpi->node_comm.root()) 
      mpi->internode_comm.all_reduce_in_place_n(k2g.data(),k2g.size(),std::plus<>{});
    mpi->comm.barrier();
  }

  Pskna = sarray_t<nda::array_view<ComplexType,4>>(*mpi,{nspin,nk,long(nkb)*npol,nbnd});
  auto Ploc = Pskna.local();

  if( nkb == 0 ) return;

  using local_4Array_t = typename nda::array<ComplexType,4>;
  // default is no distribution over basis, e.g. pw index
  auto dPsia = mf::read_distributed_orbital_set_ibz<local_4Array_t>(mf,mpi->comm,'w');
  auto psi = dPsia.local();
  utils::check(psi.extent(3) == npol*ngm, "Shape mismatch.");

  // MAM: This is still not optimal! Could be problematic in large grid problems!
  // {nk,nkb,ngm}
  nda::array<ComplexType,2> buff(1,npwx);
  nda::array<ComplexType,1> vkb(ngm);
  // read and reorder vkb
  for( auto [is,s] : itertools::enumerate(dPsia.local_range(0)) ) {
    for( auto [ik,k] : itertools::enumerate(dPsia.local_range(1)) ) {
      for( int ib=0; ib<nkb; ++ib ) { 
        auto b_k = buff(all,range(npw(k)));
        auto tpl = std::tuple{range(ib,ib+1),range(npw(k))};
        nda::h5_read(grp,"projector_k"+std::to_string(k),b_k,tpl);
        vkb() = ComplexType(0.0);
        for( auto [in,n] : itertools::enumerate(k2g(k,range(npw(k)))) ) 
          vkb(n) = std::conj(buff(0,in)); 
        for(int ip=0; ip<npol; ++ip) 
          nda::blas::gemv(ComplexType(1.0),psi(is,ik,all,range(ip*ngm,(ip+1)*ngm)),vkb,
                          ComplexType(0.0),Ploc(s,k,ib*npol+ip,dPsia.local_range(2)));
      }
    }
  } 
  mpi->comm.barrier();
  if(mpi->node_comm.root()) 
    mpi->internode_comm.all_reduce_in_place_n(Ploc.data(),Ploc.size(),std::plus<>{});
  mpi->comm.barrier();

}

// This should only be called by a single task
void pseudopot::save(std::string fname, bool append)
{ 
  if(ptype == pp_FILE_t) return; 
  char mode = (append?'a':'w');
  h5::file file;
  try {
    file = h5::file(fname, mode);
  } catch(...) {
    APP_ABORT("Failed to open h5 file: {}, mode:{}",fname,mode);
  }
  h5::group grp(file);
  pseudopot_to_h5(fft_mesh,grp,input_file_name,input_file_type);
}

// This should only be called by a single task
// MAM: save from files directly, to avoid needing to construct the object
void pseudopot::save(h5::group& grp0)
{
  if(ptype == pp_FILE_t) return; 
  pseudopot_to_h5(fft_mesh,grp0,input_file_name,input_file_type);
}

void pseudopot::add_vnl_impl(nda::range k_range, nda::range b_range, 
                   nda::ArrayOfRank<3> auto const& Dion,
		   math::nda::DistributedArrayOfRank<4> auto & Hij)
{
  using nda::range;
  // checks have already been done 
  decltype(range::all) all;
  constexpr auto MEM = memory::get_memory_space<std::decay_t<decltype(Hij.local())>>(); 

  auto k_range_loc = Hij.local_range(1) + k_range.first();
  auto b_range_loc = Hij.local_range(2) + b_range.first();
  long nkb = Pskna.shape()[2]/npol;
  long nbnd = b_range_loc.size(); 

  if( nkb == 0 ) return;

  // non-local part, directly into Hij
  auto Hijloc = Hij.local();
  auto Ploc = Pskna.local();

  // Hij(s,k,a,b) = sum_np_qn' conj(Pskna(s,k,np,a)) D(np,n'q) Pskna(s,k,n'q,b) 
  // for each (s,k)
  // T(a,n'q) = sum_np conj(Pskna(s,k,np,a)) D(np,n'q)
  // Hij(s,k,a,b) = sum_n'q T(a,n'q) * Pskna(s,k,n'q,b) 
  if constexpr (MEM == HOST_MEMORY) {     
    memory::array<MEM, ComplexType, 2> T(nbnd,nkb*npol);  
    for( auto [is,s] : itertools::enumerate(Hij.local_range(0)) )
      for( auto [ik,k] : itertools::enumerate(k_range_loc) ) {
        for( auto [ia,nt] : itertools::enumerate(ityp) )
  	{
          if(nh(nt) == 0) continue;
          long id = ( ptype == pp_ncpp_t ? nt : ia ); 
          nda::blas::gemm(ComplexType(1.0),
                  nda::dagger(Ploc(s,k,range(ofs(ia)*npol,(ofs(ia)+nh(nt))*npol),b_range_loc)),
                  Dion(id,range(nh(nt)*npol),range(nh(nt)*npol)),
                  ComplexType(0.0),T(all,range(ofs(ia)*npol,(ofs(ia)+nh(nt))*npol)));
        }
        nda::blas::gemm(ComplexType(1.0),T,Ploc(s,k,all,b_range),
                        ComplexType(1.0),Hijloc(is,ik,all,all)); 
      }
  } else { 
#if defined(ENABLE_DEVICE)
    long nk = k_range_loc.size(); 
    memory::array<MEM, ComplexType, 4> T(Hij.local_range(0).size(),nk,nbnd,nkb*npol);  
// MAM: cutensor always synchronizes right now, fix this!!!
//      or submit with streams!
// MAM: Keeping Pskna in CPU memory and making transfers every time.
// This tensor gets large, no need to keep it in GPU memory outside of this routine.
// Measure transfer time and print! This could be slow!
    auto Ploc_d = nda::to_device(Ploc);
    auto Dion_d = nda::to_device(Dion);
    for( auto [is,s] : itertools::enumerate(Hij.local_range(0)) )
      for( auto [ia,nt] : itertools::enumerate(ityp) )
      {
        if(nh(nt) == 0) continue;
        long id = ( ptype == pp_ncpp_t ? nt : ia ); 
        nda::tensor::contract(
          nda::conj(Ploc_d(s,k_range_loc,range(ofs(ia)*npol,(ofs(ia)+nh(nt))*npol),b_range_loc)),"kma",
          Dion_d(id,range(nh(nt)*npol),range(nh(nt)*npol)),"mn",
          T(is,all,all,range(ofs(ia)*npol,(ofs(ia)+nh(nt))*npol)),"kan");
      }
    nda::tensor::contract(ComplexType(1.0),T,"skan",
                          Ploc_d(Hij.local_range(0),k_range_loc,all,b_range),"sknb",
                          ComplexType(1.0),Hijloc,"skab");
#else
    static_assert(MEM!=HOST_MEMORY, "Error: Device code without device support.");
#endif
  }
}

// MAM: This routine should take an mpi_context and use it, instead of mpi
//      since we are currently calling it with a different set of processes
template< nda::ArrayOfRank<3> Arr3, nda::ArrayOfRank<4> Arr4>
void pseudopot::add_vpp_impl(boost::mpi3::communicator& comm,
                   nda::range k_range, nda::range b_range, 
		   math::nda::DistributedArrayOfRank<4> auto const& psi,
		   math::nda::DistributedArrayOfRank<4> auto & hpsi,
		   math::nda::DistributedArrayOfRank<4> auto & Hij,
                   const Arr3 * nii, const Arr4 * nij)
{
  pots::potential_t vG(ptree{});

  decltype(nda::range::all) all;
  constexpr auto MEM = memory::get_memory_space<std::decay_t<decltype(psi.local())>>(); 
  constexpr auto MEM1 = memory::get_memory_space<std::decay_t<decltype(hpsi.local())>>(); 
  constexpr auto MEM2 = memory::get_memory_space<std::decay_t<decltype(Hij.local())>>(); 
  static_assert(MEM == MEM1, "Memory mismatch.");
  static_assert(MEM == MEM2, "Memory mismatch.");

  auto k_range_loc = psi.local_range(1) + k_range.first();
  utils::check(k_range.size() == psi.global_shape()[1], "Shape mismatch: {},{}",k_range.size(),psi.global_shape()[1]);
  utils::check(b_range.size() == psi.global_shape()[2], "Shape mismatch: {},{}",b_range.size(),psi.global_shape()[2]);
  utils::check(psi.global_shape() == hpsi.global_shape(), "Shape mismatch");
  utils::check(psi.local_shape() == hpsi.local_shape(), "Shape mismatch");
  utils::check(psi.origin() == hpsi.origin(), "Shape mismatch");
  utils::check(psi.local_range(3) == nda::range{0,npol*swfc_to_rho.size()}, 
               "Range mismatch");
  utils::check(psi.grid()[3] == 1, "Processor grid mismatch");
  utils::check(k_range_loc.first() >= 0 and
               k_range_loc.last()  <= nkpts_ibz, "Range mismatch.");
  utils::check(psi.global_shape()[0] == Hij.global_shape()[0], "Shape mismatch");
  utils::check(psi.global_shape()[1] == Hij.global_shape()[1], "Shape mismatch");
  utils::check(psi.global_shape()[2] == Hij.global_shape()[2], "Shape mismatch");
  utils::check(psi.global_shape()[2] == Hij.global_shape()[3], "Shape mismatch");
  utils::check(psi.local_shape()[0] == Hij.local_shape()[0], "Shape mismatch");
  utils::check(psi.local_shape()[1] == Hij.local_shape()[1], "Shape mismatch");
  utils::check(psi.local_shape()[2] == Hij.local_shape()[2], "Shape mismatch");
  utils::check(Hij.global_shape()[3] == Hij.local_shape()[3], "Shape mismatch");

  /*
   *   1. calculate charge density and fft to G space
   *   2. symmetrize density
   *   3. multiply by coulomb
   *   4. fft to real space
   *   5. add to vloc
   */
  if( nii != nullptr or nij != nullptr ) {

    auto mpi_local_context = utils::make_mpi_context(comm); 

    // local pseudopotential + hartree
    sarray_t<nda::array_view<ComplexType,1>> svr(mpi_local_context,{nnr}); 
    auto vr = svr.local();
    auto vltot = svloc.local();

    utils::check( nii == nullptr or nij == nullptr, 
                  "Error in pseudo::add_vpp_impl: Both nii and nij!!");
    utils::check( k_range.first() == 0 and  k_range.last() == nkpts_ibz, 
                 "Error in add_vloc: add_hartree requires full kpoint range.");
    // calculate and add hartree term with diagonal occupation matrix
    if( nii != nullptr)
      hamilt::v_h(*mpi, vG, npol, fft_mesh, lattv, recv, swfc_to_rho.local(), kpts, kp_to_ibz,
                  kp_trev, kp_symm, symm_list, *nii, psi, false, svr);
    else
      hamilt::v_h(*mpi, vG, npol, fft_mesh, lattv, recv, swfc_to_rho.local(), kpts, kp_to_ibz,
                  kp_trev, kp_symm, symm_list, *nij, psi, false, svr);

    mpi->node_comm.barrier();
    // accumulate on vltot, remove afterwards
    if(mpi->node_comm.root()) {
      // vr is spin independent and acts only on diagonal components in polarization space
      for( auto is: nda::range(vltot.extent(0)) ) {
        for( auto ip: nda::range(vltot.extent(1)) ) {
          vltot(is,ip*npol+ip,all) += vr;
        }
      }
    }
    mpi->node_comm.barrier();

    // local potential
    hamilt::add_vloc(npol,fft_mesh,swfc_to_rho.local(),vltot,psi,hpsi);

    mpi->node_comm.barrier();
    // restore vltot (remove vr) 
    if(mpi->node_comm.root()) {
      for( auto is: nda::range(vltot.extent(0)) ) {
        for( auto ip: nda::range(vltot.extent(1)) ) {
          vltot(is,ip*npol+ip,all) -= vr;
        }
      }
    }
    mpi->node_comm.barrier();

  } else {

    // local potential
    auto vltot = svloc.local();
    hamilt::add_vloc(npol,fft_mesh,swfc_to_rho.local(),vltot,psi,hpsi);

  }

  // non-local part, directly into Hij
  if( ptype == pp_ncpp_t ) {
    add_vnl_impl(k_range, b_range, Dnn.local(), Hij); 
  } else { 
    utils::check( false, "finish" );
  }

}

void pseudopot::add_Vpp(boost::mpi3::communicator& comm,
                   nda::range k_range, nda::range b_range, 
		   math::nda::DistributedArrayOfRank<4> auto const& psi,
		   math::nda::DistributedArrayOfRank<4> auto & hpsi,
		   math::nda::DistributedArrayOfRank<4> auto & Hij)
{
  constexpr auto MEM = memory::get_memory_space<std::decay_t<decltype(psi.local())>>(); 
  constexpr auto MEM1 = memory::get_memory_space<std::decay_t<decltype(hpsi.local())>>();
  constexpr auto MEM2 = memory::get_memory_space<std::decay_t<decltype(Hij.local())>>();
  static_assert(MEM == MEM1, "Memory mismatch.");
  static_assert(MEM == MEM2, "Memory mismatch.");
  memory::array<MEM,ComplexType,3>* p3 = nullptr;
  memory::array<MEM,ComplexType,4>* p4 = nullptr;
  add_vpp_impl(comm,k_range,b_range,psi,hpsi,Hij,p3,p4);
}

void pseudopot::add_Vpp(boost::mpi3::communicator& comm,
                   nda::range k_range, nda::range b_range, 
                   nda::ArrayOfRank<3> auto const& nii, 
                   math::nda::DistributedArrayOfRank<4> auto const& psi,
                   math::nda::DistributedArrayOfRank<4> auto & hpsi,
                   math::nda::DistributedArrayOfRank<4> auto & Hij)
{
  constexpr auto MEM = memory::get_memory_space<std::decay_t<decltype(psi.local())>>(); 
  constexpr auto MEM1 = memory::get_memory_space<std::decay_t<decltype(hpsi.local())>>();
  constexpr auto MEM2 = memory::get_memory_space<std::decay_t<decltype(Hij.local())>>();
  static_assert(MEM == MEM1, "Memory mismatch.");
  static_assert(MEM == MEM2, "Memory mismatch.");
  memory::array<MEM,ComplexType,4>* p4 = nullptr;
  add_vpp_impl(comm,k_range,b_range,psi,hpsi,Hij,std::addressof(nii),p4);
}

void pseudopot::add_Vpp(boost::mpi3::communicator& comm,
                   nda::range k_range, nda::range b_range, 
                   nda::ArrayOfRank<4> auto const& nij,
                   math::nda::DistributedArrayOfRank<4> auto const& psi,
                   math::nda::DistributedArrayOfRank<4> auto & hpsi,
                   math::nda::DistributedArrayOfRank<4> auto & Hij)
{ 
  constexpr auto MEM = memory::get_memory_space<std::decay_t<decltype(psi.local())>>(); 
  constexpr auto MEM1 = memory::get_memory_space<std::decay_t<decltype(hpsi.local())>>();
  constexpr auto MEM2 = memory::get_memory_space<std::decay_t<decltype(Hij.local())>>();
  static_assert(MEM == MEM1, "Memory mismatch.");
  static_assert(MEM == MEM2, "Memory mismatch.");
  memory::array<MEM,ComplexType,3>* p3 = nullptr;
  add_vpp_impl(comm,k_range,b_range,psi,hpsi,Hij,p3,std::addressof(nij));
}

// MAM: This routine should take an mpi_context and use it, instead of mpi
template<nda::ArrayOfRank<3> Arr3, nda::ArrayOfRank<4> Arr4>
void pseudopot::add_Hartree_impl(nda::range k_range,
                                 math::nda::DistributedArrayOfRank<4> auto const& psi,
                                 math::nda::DistributedArrayOfRank<4> auto & hpsi,
                                 const Arr3 *nii, const Arr4 *nij, bool symmetrize) {
  constexpr auto MEM = memory::get_memory_space<std::decay_t<decltype(psi.local())>>();
  constexpr auto MEM1 = memory::get_memory_space<std::decay_t<decltype(hpsi.local())>>();
  static_assert(MEM == MEM1, "Memory mismatch.");

  auto k_range_loc = psi.local_range(1) + k_range.first();
  utils::check(k_range.size() == psi.global_shape()[1], "Shape mismatch: {},{}",k_range.size(),psi.global_shape()[1]);
  utils::check(psi.global_shape() == hpsi.global_shape(), "Shape mismatch");
  utils::check(psi.local_shape() == hpsi.local_shape(), "Shape mismatch");
  utils::check(psi.origin() == hpsi.origin(), "Shape mismatch");
  utils::check(psi.local_range(3) == nda::range{0,npol*swfc_to_rho.size()},
               "Range mismatch");
  utils::check(psi.grid()[3] == 1, "Processor grid mismatch");
  utils::check(k_range_loc.first() >= 0 and
               k_range_loc.last()  <= nkpts_ibz, "Range mismatch.");

  auto sv_hartree = make_shared_array<nda::array_view<ComplexType, 1>>(*mpi, {nnr});
  auto v_hartree = sv_hartree.local();

  // MAM: this must be passed to the routine
  pots::potential_t vG(ptree{});

  utils::check(nii == nullptr or nij == nullptr,
               "Error in pseudo::add_Hartree_impl: Both nii and nij exist!");
  utils::check(k_range.first() == 0 and k_range.last() == nkpts_ibz,
               "Error in add_Hartree_impl: add_hartree requires full kpoint range.");
  // calculate and add hartree term with diagonal occupation matrix
  if (nii != nullptr)
    hamilt::v_h(*mpi, vG, npol, fft_mesh, lattv, recv, swfc_to_rho.local(), kpts, kp_to_ibz,
                kp_trev, kp_symm, symm_list, *nii, psi, symmetrize, sv_hartree);
  else
    hamilt::v_h(*mpi, vG, npol, fft_mesh, lattv, recv, swfc_to_rho.local(), kpts, kp_to_ibz,
                kp_trev, kp_symm, symm_list, *nij, psi, symmetrize, sv_hartree);

  // add v_hartree to hpsi
  hamilt::add_vloc(npol, fft_mesh, swfc_to_rho.local(), v_hartree, psi, hpsi);

}

void pseudopot::add_Hartree(nda::range k_range,
                            nda::ArrayOfRank<3> auto const& nii,
                            math::nda::DistributedArrayOfRank<4> auto const& psi,
                            math::nda::DistributedArrayOfRank<4> auto & hpsi,
                            bool symmetrize) {
  nda::array<ComplexType, 4>* p4 = nullptr;
  add_Hartree_impl(k_range, psi, hpsi, std::addressof(nii), p4, symmetrize);
}

void pseudopot::add_Hartree(nda::range k_range,
                            nda::ArrayOfRank<4> auto const& nij,
                            math::nda::DistributedArrayOfRank<4> auto const& psi,
                            math::nda::DistributedArrayOfRank<4> auto & hpsi,
                            bool symmetrize) {
  nda::array<ComplexType,3>* p3 = nullptr;
  add_Hartree_impl(k_range, psi, hpsi, p3, std::addressof(nij), symmetrize);
}


using memory::darray_t;
using memory::host_array;
using memory::host_array_view;

template pseudopot::pseudopot(mf::MF&,std::string const);
template void pseudopot::read_vnl_pw2bgw(mf::MF &, std::string);
template void pseudopot::read_vnl_h5(mf::MF &, h5::group&); 

#define __add_Vpp__(V) \
template void pseudopot::add_Vpp(boost::mpi3::communicator&,nda::range,nda::range, \
        darray_t<V<ComplexType,4>,communicator> const&, \
        darray_t<V<ComplexType,4>,communicator>&, \
        darray_t<V<ComplexType,4>,communicator>&); \
template void pseudopot::add_Vpp(boost::mpi3::communicator&,nda::range,nda::range, \
        V<ComplexType,3> const&, \
        darray_t<V<ComplexType,4>,communicator> const&, \
        darray_t<V<ComplexType,4>,communicator>&, \
        darray_t<V<ComplexType,4>,communicator>&); \
template void pseudopot::add_Vpp(boost::mpi3::communicator&,nda::range,nda::range, \
        V<ComplexType,4> const&,  \
        darray_t<V<ComplexType,4>,communicator> const&,  \
        darray_t<V<ComplexType,4>,communicator>&,  \
        darray_t<V<ComplexType,4>,communicator>&);  \

#define __add_Vpp2__(V1,V2) \
template void pseudopot::add_Vpp(boost::mpi3::communicator&,nda::range,nda::range, \
        V1<ComplexType,3> const&, \
        darray_t<V2<ComplexType,4>,communicator> const&, \
        darray_t<V2<ComplexType,4>,communicator>&, \
        darray_t<V2<ComplexType,4>,communicator>&); \
template void pseudopot::add_Vpp(boost::mpi3::communicator&,nda::range,nda::range, \
        V1<ComplexType,4> const&, \
        darray_t<V2<ComplexType,4>,communicator> const&, \
        darray_t<V2<ComplexType,4>,communicator>&, \
        darray_t<V2<ComplexType,4>,communicator>&); 

#define __add_hartree__(V1,V2)  \
template void pseudopot::add_Hartree(nda::range k_range,  \
        V1<ComplexType, 3> const&,  \
        darray_t<V2<ComplexType,4>,communicator> const&,  \
        darray_t<V2<ComplexType,4>,communicator>&, bool);  \
template void pseudopot::add_Hartree(nda::range k_range,  \
        V1<ComplexType, 4> const&,  \
        darray_t<V2<ComplexType,4>,communicator> const&,  \
        darray_t<V2<ComplexType,4>,communicator>&, bool);  

__add_Vpp__(host_array)
__add_Vpp2__(host_array_view,host_array)

__add_hartree__(host_array,host_array)
__add_hartree__(host_array_view,host_array)

#if defined(ENABLE_DEVICE)
using memory::device_array;
using memory::unified_array;
using memory::device_array_view;
using memory::unified_array_view;


__add_Vpp__(device_array)
__add_Vpp2__(device_array_view,device_array)
__add_hartree__(host_array,device_array)
__add_hartree__(host_array_view,device_array)
__add_hartree__(unified_array,device_array)
__add_hartree__(unified_array_view,device_array)
__add_hartree__(device_array,device_array)
__add_hartree__(device_array_view,device_array)

__add_Vpp__(unified_array)
__add_Vpp2__(unified_array_view,unified_array)
__add_hartree__(host_array,unified_array)
__add_hartree__(host_array_view,unified_array)
__add_hartree__(unified_array,unified_array)
__add_hartree__(unified_array_view,unified_array)

#endif

} // namespace hamilt


