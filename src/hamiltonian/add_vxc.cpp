
#include "mpi3/communicator.hpp"
#include "numerics/distributed_array/nda.hpp"
#include "numerics/shared_array/nda.hpp"
#include "mean_field/MF.hpp"
#include "add_vloc.hpp"
#include "add_vxc.h"

namespace hamilt
{

using boost::mpi3::communicator;
using boost::mpi3::shared_communicator;
using utils::mpi_context_t;
using math::shm::shared_array;

template<typename MF_t>
void add_vxc(MF_t& mf, nda::range k_range, nda::range b_range,
             math::nda::DistributedArrayOfRank<4> auto const& psi,
             math::nda::DistributedArrayOfRank<4> auto & hpsi) {
  using math::nda::make_distributed_array;
  using value_t = typename std::decay_t<decltype(psi)>::value_type;
  static_assert( std::is_same_v<typename std::decay_t<decltype(hpsi)>::value_type,value_t>, "Type mismatch.");

  auto comm = psi.communicator();
  auto mpi_context = utils::make_mpi_context(*comm);

  int nspin = mf.nspin();
  int npol = mf.npol();
  auto fft_mesh = mf.fft_grid_dim();
  auto swfc_to_rho = detail::make_wfc_to_rho(mpi_context, mf, fft_mesh);
  auto svxc = shared_array<nda::array_view<ComplexType,3>>(mpi_context, {nspin, npol*npol, mf.nnr()});

  utils::check(k_range.size() == mf.nkpts_ibz() and
               b_range.size() == mf.nbnd(), "add_vxc: partial k_range/b_range not yet implemented.");
  utils::check(k_range.size() == psi.global_shape()[1], "add_vxc: k_range/psi shape mismatch.");
  utils::check(b_range.size() == psi.global_shape()[2], "add_vxc: b_range/psi shape mismatch.");

  // read vxc potential
  if( mf.input_file_type() == mf::xml_input_type and mf.mf_type() == mf::qe_source ) {
    // read ASCII and binary files generated by QE::pp.x and QE::pw2bgw.x
    auto input_file_name = mf.outdir();
    utils::check(false, "read_vxc_pw2bgw is not implemented yet. "
                        "Consider using pw2coqui.x interface.");
    //auto vxc = read_vxc_pw2bgw(mf, mf.outdir());
  } else if(mf.input_file_type() == mf::h5_input_type) {
    utils::check(std::filesystem::exists(mf.filename()), "Error: Missing file: {}",mf.filename());
    auto input_file_name = mf.filename();
    h5::file file;
    try {
      file = h5::file(mf.filename(), 'r');
    } catch(...) {
      APP_ABORT("Failed to open h5 file: {}, mode:r",mf.filename());
    }
    h5::group grp(file);
    read_vxc_h5(mf, grp, svxc);
  } else
    utils::check(false,"Error in hamilt::add_vxc:: Unknown input file type/mf object combination.");

  // add vxc to hpsi
  add_vloc(npol, fft_mesh, swfc_to_rho.local(), svxc.local(), psi, hpsi);
}

template<typename MF_t, nda::MemoryArrayOfRank<3> array_t>
void read_vxc_h5(MF_t &mf, h5::group& grp0, shared_array<array_t> &svxc)
{
  std::string type("");

  h5::group grp1 = grp0.open_group("Hamiltonian");
  h5::h5_read_attribute(grp1, "pp_type", type);

  if (type != "ncpp" and type != "uspp" and type != "paw") {
    APP_ABORT("Invalid pp_type: {}", type);
  }

  h5::group grp = grp1.open_group(type);

  int nspin, npol, nk, npwx;
  h5::h5_read_attribute(grp,"number_of_nspins",nspin);
  h5::h5_read_attribute(grp,"number_of_polarizations",npol);
  h5::h5_read_attribute(grp,"number_of_kpoints",nk);
  h5::h5_read_attribute(grp,"max_npw",npwx);

  utils::check(nspin == mf.nspin(), "Error in pseudopot::read_vxc_h5: Inconsistent nspin.");
  utils::check(npol == mf.npol(), "Error in pseudopot::read_vxc_h5: Inconsistent npol.");
  utils::check(nk == mf.nkpts_ibz(), "Error in pseudopot::read_vxc_h5: Inconsistent nkpts.");
  utils::check(mf.wfc_truncated_grid()->size() >= npwx,
               "Error in pseudopot::read_vxc_h5: ngm < max_npw");
  utils::check(svxc.shape() == std::array<long,3>{nspin,npol*npol,mf.nnr()}, 
               "Error in pseudopot::read_vxc_h5: Inconsistent vxc shape.");

  auto fft_mesh = mf.fft_grid_dim();
  auto vxc = svxc.local();

  if(svxc.communicator()->root()) {
    int ngm;
    h5::h5_read_attribute(grp,"ngm",ngm);
    nda::array<ComplexType,3> vl(nspin,npol*npol,ngm);
    nda::array<long,1> k2g(ngm);

    auto vxc_4D = nda::reshape(vxc,std::array<long,4>{nspin*npol*npol,fft_mesh(0),fft_mesh(1),fft_mesh(2)});
    math::nda::fft<true> F(vxc_4D);

    {
      nda::array<int,2> mill_g(ngm,3);
      nda::h5_read(grp,"miller_g",mill_g);
      utils::generate_k2g(mill_g,k2g,fft_mesh);
    }

    // vxc
    auto vxc_2D = nda::reshape(vxc,std::array<long,2>{nspin*npol*npol,mf.nnr()});
    auto vl_2D = nda::reshape(vl,std::array<long,2>{nspin*npol*npol,ngm});
    vxc_2D() = ComplexType(0.0);
    nda::h5_read(grp,"vxc_with_nlcc",vl);
    nda::copy_select(true,1,k2g,ComplexType(1.0),vl_2D,ComplexType(0.0),vxc_2D);
    F.backward(vxc_4D);

    // to Hartree unit
    nda::tensor::scale(ComplexType(0.5), vxc_2D);
  }
  if(svxc.node_comm()->root()) {
    svxc.internode_comm()->broadcast_n(svxc.local().data(), svxc.size(), 0);
  }
  svxc.communicator()->barrier();
}


using memory::darray_t;
using memory::host_array;
using memory::host_array_view;

template void add_vxc(mf::MF&, nda::range, nda::range,
    darray_t<host_array<ComplexType,4>,communicator> const&,
    darray_t<host_array<ComplexType,4>,communicator>&);
#if defined(ENABLE_DEVICE)
using memory::device_array;
using memory::unified_array;
using memory::device_array_view;
using memory::unified_array_view;

template void add_vxc(mf::MF&, nda::range, nda::range,
    darray_t<device_array<ComplexType,4>,communicator> const&,
    darray_t<device_array<ComplexType,4>,communicator>&);
template void add_vxc(mf::MF&, nda::range, nda::range,
    darray_t<unified_array<ComplexType,4>,communicator> const&,
    darray_t<unified_array<ComplexType,4>,communicator>&);
#endif

template void read_vxc_h5(mf::MF&, h5::group&, shared_array<nda::array_view<ComplexType,3>>&);

} // namespace hamilt
