/**
 * ==========================================================================
 * CoQuí: Correlated Quantum ínterface
 *
 * Copyright (c) 2022-2025 Simons Foundation & The CoQuí developer team
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ==========================================================================
 */


#ifndef ORBITALS_PGTO_H
#define ORBITALS_PGTO_H

#include <map>
#include <vector>
#include <string>

#include "configuration.hpp"
#include "grids/g_grids.hpp"
#include "nda/concepts.hpp"
#include "numerics/distributed_array/nda.hpp"
#include "mean_field/MF.hpp"

namespace orbitals
{

struct orbital_shell
{
  // Angular momentum, 0:s, 1:p, 2:d, ...
  int L;  
  nda::stack_array<double,3> R;   // position of center
  // p(i,0): ith exponent 
  // p(i,1): ith expansion coefficient of orbital #1 
  // ...
  // p(i,n): ith expansion coefficient of orbital #n  
  nda::array<double,2> p; 
};

/* 
 * Class pgto generates periodic gaussian basis sets.
 * Basis sets are read from standard quantum chemistry formats (e.g. gamess, molpro, nwchem, etc).
 */
class pgto
{
  public:
// MAM: to do: Add ptree constructor, which parses arguments and reads list of species and associated files 
  pgto() = default;
  ~pgto() = default;

  pgto(pgto const&) = default;
  pgto(pgto&&) = default;
  pgto& operator=(pgto const&) = default; 
  pgto& operator=(pgto&&) = default; 
  
  /*
   * Reads a basis set from file and adds orbitals to the basis set at the provided centers (position in the lattice). 
   */ 
  void add(std::string tag, nda::array<double,2> const& R, std::string,std::string);

  /*
   * Reads a basis set from file and adds orbitals to the basis set at the provided centers (position in the lattice). 
   */ 
  void add(mf::MF& mf,std::string,std::string);

  /*
   * Number of orbital shells. 
   */ 
  long number_of_shells() const { 
    long n=0;
    for( auto& v : G ) n+=(v.p.shape()[1]-1); 
    return n;
  };

  /*
   * Number of orbital centers. 
   */ 
//  long number_of_centers() const { return G.size(); } 

  /*
   * Number of orbital centers. 
   */
//  long number_of_shells(long i) const { 
//    utils::check(i<G.size() and i>=0, "Out of bounds.");
//    return G[i].p.shape()[1]-1; 
//  }

  /*
   * Number of basis functions associated with orbital center i. 
   */ 
  long size(long i) const {
    utils::check(i<G.size() and i>=0, "Out of bounds.");
    return (2*G[i].L+1)*(G[i].p.shape()[1]-1);
  }  

  /*
   * Number of basis functions generated by generate_basis_set.
   */
  long size() const {
    long n=0;
    for( int i=0; i<G.size(); ++i ) n+=size(i); 
    return n;
  }

  /*
   * Returns reference to orbital center
   */ 
  auto shell(long i) const {
    decltype(nda::range::all) all;
    utils::check( i>0 and i<number_of_shells(), "Out of bounds");
    return std::make_tuple(G[i].L, G[i].R(), G[i].p(all,0), G[i].p(all,i+1)); 
  }

  /*
   * Returns reference to orbital center
   */
  auto shell_sizes() const {
    nda::array<int,1> sz(number_of_shells());
    long n=0;
    for( auto& v : G ) {
      int m = (v.p.shape()[1]-1);
      sz(nda::range(n,n+m))=(2*v.L+1);
      n+=m;
    }
    return sz;
  }

  /*
   * Prints to screen the details of the basis
   */ 
  void print_basis_info(int lvl=2)
  {
    app_log(lvl,"******************************************"); 
    app_log(lvl," PGTO Basis Set: "); 
    app_log(lvl," Number of shells: {}",number_of_shells());
    long n=0;
    for( int i=0; i<G.size(); ++i ) {
      app_log(lvl," - Center #{}, L:{}, n_Orbs:{}, R:({},{},{}) ",
                           i,G[i].L,G[i].p.shape()[1]-1,G[i].R(0),G[i].R(1),G[i].R(2));
      n+=size(i);
    }
    app_log(lvl," Size of basis: {}",n);
    app_log(lvl,"******************************************"); 
  }

  template<MEMORY_SPACE MEM = HOST_MEMORY, typename comm_t>
  memory::darray_t<memory::array<MEM,ComplexType,4>, comm_t>  
  generate_basis_set(comm_t& comm, 
		     mf::MF& mf,
		     bool normalize = false,
		     std::array<long,4> const pgrid = {0},
		     std::array<long,4> const bz = {1,1,2048,2048});

  private:

  // list of orbital centers 
  std::vector<orbital_shell> G; 
  
  std::vector<orbital_shell> parse_gamess(std::string,std::string tag);
  std::vector<orbital_shell> parse_nwchem(std::string,std::string tag);
  std::vector<orbital_shell> parse_molpro(std::string,std::string tag);

  void make_orbital(nda::ArrayOfRank<2> auto const& kpts,
		    nda::ArrayOfRank<1> auto const& mesh, 
		    nda::ArrayOfRank<2> auto const& lattv,
		    math::nda::DistributedArrayOfRank<4> auto&& psir);
  
};

}

#endif
